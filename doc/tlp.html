<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>tlp API documentation</title>
<meta name="description" content="Funkcije za predviđanje veza u mreži kroz vrijeme …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tlp</code></h1>
</header>
<section id="section-intro">
<p>Funkcije za predviđanje veza u mreži kroz vrijeme.</p>
<h2 id="zavisnosti">Zavisnosti</h2>
<p>Kod je izvršiv samo u <strong><em>Python</em> 3</strong> okruženju zbog svojih zavisnosti.</p>
<ol>
<li>standardna <em>Python</em> biblioteka:<ol>
<li><a href="http://docs.python.org/3/library/copy.html">copy</a>,</li>
<li><a href="http://docs.python.org/3/library/functools.html">functools</a>,</li>
<li><a href="http://docs.python.org/3/library/math.html">math</a>,</li>
<li><a href="http://docs.python.org/3/library/numbers.html">numbers</a>,</li>
</ol>
</li>
<li>ostali paketi:<ol>
<li><a href="http://numpy.org/">NumPy</a> &ndash; tenzori su reprezentirani kao objekti
klase <code>numpy.ndarray</code>.</li>
<li><a href="http://tensorly.org/">TensorLy</a> &ndash; dekompozicija tenzora
realizirana je metodama iz biblioteke paketa <em>TensorLy</em> (taj je paket
podržan samo za <em>Python</em> 3 okruženje).</li>
</ol>
</li>
</ol>
<h2 id="napomene">Napomene</h2>
<p>U ostatku dokumentacije pretpostavlja se da su izvršene linije</p>
<pre><code class="Python">import numpy as np
import tensorLy as tl

from tlp import *
</code></pre>
<h2 id="literatura">Literatura</h2>
<ol>
<li><a class="anchor" id="bib-dunlavy-10"></a> D. M. Dunlavy, T. G. Kolda, E.
Acar, <em>Temporal Link Prediction using Matrix and Tensor Factorizations</em>,
2010, arXiv: <a href="http://arxiv.org/abs/1005.4006">1005.4006 [math.NA]</a>.</li>
</ol>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Funkcije za predviđanje veza u mreži kroz vrijeme.

##  Zavisnosti

Kod je izvršiv samo u ***Python* 3** okruženju zbog svojih zavisnosti.

1.  standardna *Python* biblioteka:
    1.  [copy](http://docs.python.org/3/library/copy.html),
    2.  [functools](http://docs.python.org/3/library/functools.html),
    3.  [math](http://docs.python.org/3/library/math.html),
    4.  [numbers](http://docs.python.org/3/library/numbers.html),
2.  ostali paketi:
    1.  [NumPy](http://numpy.org/) &amp;ndash; tenzori su reprezentirani kao objekti
        klase `numpy.ndarray`.
    2.  [TensorLy](http://tensorly.org/) &amp;ndash; dekompozicija tenzora
        realizirana je metodama iz biblioteke paketa *TensorLy* (taj je paket
        podržan samo za *Python* 3 okruženje).

##  Napomene

U ostatku dokumentacije pretpostavlja se da su izvršene linije

```Python
import numpy as np
import tensorLy as tl

from tlp import *
```

##  Literatura

1.  &lt;a class=\&#34;anchor\&#34; id=\&#34;bib-dunlavy-10\&#34;&gt;&lt;/a&gt; D. M. Dunlavy, T. G. Kolda, E.
    Acar, *Temporal Link Prediction using Matrix and Tensor Factorizations*,
    2010, arXiv: [1005.4006 [math.NA]](http://arxiv.org/abs/1005.4006).

&#34;&#34;&#34;

# Standardna Python biblioteka.
import copy as _copy
import functools as _functools
import math as _math
import numbers as _numbers

# SciPy paketi.
import numpy as _np

# TensorLy paket.
import tensorly as _tl
from tensorly.decomposition import parafac as _parafac

# Osiguraj da se koristi numpy backend u TensorLy-ju.
if _tl.get_backend() != &#39;numpy&#39;:
    _tl.set_backend(&#39;numpy&#39;)

def cwt (Z, theta = 0.5, norm = False):
    &#34;&#34;&#34;
    Izračunaj *collapsed weighted tensor* (*CWT*).

    *CWT* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CWT* računa.

    theta : float in range [0 to 1), optional
        Parametar *gubitka* relevantnosti stanja kroz vrijeme (zadana vrijednost
        je 0.5).

    norm : boolean, optional
        Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
        to jest, povratna vrijednost je podijeljena sa
        `sum((1.0 - theta) ** i for i in range(Z.shape[-1]))` (zadana
        vrijednost je laž).

    Povratne vrijednosti
    --------------------
    array
        *CWT* zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je za 1
        manje od tenzora `Z`, a oblikom je jednak obliku `Z.shape[:-1]`.  Ako je
        `Z` jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `theta` nije
        realni broj.

    ValueError
        Parametar `Z` je skalar ili prazni tenzor, parametar `theta` nije u
        intervalu [0, 1).

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cwt(Z)
    array([[ 2.5,  5.5,  8.5, 11.5],
           [14.5, 17.5, 20.5, 23.5],
           [26.5, 29.5, 32.5, 35.5]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0)
    array([[ 3.,  7., 11., 15.],
           [19., 23., 27., 31.],
           [35., 39., 43., 47.]])
    &gt;&gt;&gt; cwt(Z, norm = True).round(3)
    array([[ 1.667,  3.667,  5.667,  7.667],
           [ 9.667, 11.667, 13.667, 15.667],
           [17.667, 19.667, 21.667, 23.667]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
    array([[ 1.5,  3.5,  5.5,  7.5],
           [ 9.5, 11.5, 13.5, 15.5],
           [17.5, 19.5, 21.5, 23.5]])

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar theta.
    if not isinstance(theta, _numbers.Real):
        raise TypeError(&#39;theta mora biti realni broj.&#39;)
    try:
        theta = _copy.deepcopy(float(theta))
    except (TypeError, ValueError):
        raise TypeError(&#39;theta mora biti klase float.&#39;)
    if _math.isnan(theta) or _math.isinf(theta):
        raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
    if not (theta &gt;= 0.0 and theta &lt; 1.0):
        raise ValueError(&#39;theta mora biti u intervalu [0, 1).&#39;)

    # Saniraj parametar norm.
    if not isinstance(
        norm,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)
    if norm not in {0, False, 1, True}:
        raise ValueError(&#39;norm mora biti laz/istina.&#39;)
    try:
        norm = _copy.deepcopy(bool(norm))
    except (TypeError, ValueError):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)

    # Izračunaj prvih Z.shape[-1] elemenata geometrijskog niza s koeficijentom
    # 1 - theta.
    one_min_theta = _np.flip(
        (1.0 - theta) ** _np.arange(Z.shape[-1], dtype = int)
    ).copy(order = &#39;F&#39;)

    # Izračunaj kompresijsku sumu.
    Z_compressed = (one_min_theta * Z).sum(axis = -1).copy(order = &#39;F&#39;)

    # Ako je norm istina, podijeli kompresijsku sumu sa _theta.sum().
    if norm:
        Z_compressed /= one_min_theta.sum()

    # Po potrebi pretvori Z u skalar.
    if isinstance(Z_compressed, _np.ndarray):
        if Z_compressed.shape == tuple():
            Z_compressed = Z_compressed.dtype.type(Z_compressed)

    # Vrati kompresijsku sumu.
    return Z_compressed

def tsvd (X, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated singular value decomposition* (*TSVD*) matrice bliskosti.

    *TSVD* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica numeričkih definiranih i konačnih vrijednosti.

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija matrice `X` na prvih
        `k` singularnih vrijednosti; inače je povratna vrijednost rekompozicija
        (zadana vrijednost je laž).

    Povratne vrijednosti
    --------------------
    X_k : (M, M) array
        Rekompozicija iz *TSVD* matrice `X` na prvih `k` singularnih
        vrijednosti.  Ova se povratna vrijednost vraća ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    s_k : (k,) array
        `k` najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
        se povratna vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `compute` nije istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `k` nije u intervalu [1, min(M, N)],
        parametar `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; X = [[ 1,  5,  0, -2],
    ...      [-2,  4,  0,  1],
    ...      [ 0, -1, -1,  0]]
    &gt;&gt;&gt; tsvd(X).round(3)
    array([[ 1.,  5., -0., -2.],
           [-2.,  4.,  0.,  1.],
           [ 0., -1., -1., -0.]])
    &gt;&gt;&gt; tsvd(X, k = 1).round(3)
    array([[-0.321,  5.1  ,  0.121, -0.769],
           [-0.243,  3.869,  0.092, -0.584],
           [ 0.063, -0.997, -0.024,  0.15 ]])
    &gt;&gt;&gt; tsvd(X, k = 2).round(3)
    array([[ 1.012,  5.   ,  0.108, -1.988],
           [-1.988,  4.   ,  0.108,  1.012],
           [ 0.108, -1.   , -0.024,  0.108]])

    Rekompozicija matrice.

    &gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[-0.787, -0.607],
           [-0.597,  0.794],
           [ 0.154, -0.021]])
    &gt;&gt;&gt; s.round(3)
    array([6.566, 2.98 ])
    &gt;&gt;&gt; V.round(3)
    array([[ 0.062, -0.737],
           [-0.987,  0.055],
           [-0.023,  0.007],
           [ 0.149,  0.674]])

    Dekompozicija matrice `X`.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `X_k == U_k @ np.diag(s_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; max(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj TSVD.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(max(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati dekompoziciju ili rekompoziciju ovisno o vrijednosti parametra
    # compute.
    return (
        _np.matmul(s * U, V.T.copy(order = &#39;F&#39;)).copy(order = &#39;F&#39;) if compute
            else (U, s, V)
    )

def t_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated Katz score* kvadratne simetrične matrice bliskosti.

    *Truncated Katz score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, M) symmetric array
        Matrica bliskosti neusmjerenog težinskog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, M], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    gamma_k : (k,) array
        Za konačni niz `l` svojstvenih vrijednosti matrice `X` poredan silazno
        po apsolutnoj vrijednosti, `gamma_k[i]` iznosi
        `(1.0 - beta * l[i]) ** -1 - 1.0`.  Ova se povratna vrijednost vraća ako
        je `compute` laž.

    W_k : (M, k) array
        Matrica normiranih stupaca.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije kvadratna simetrična matrica,
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `beta` nije u
        intervalu (0, 1), parametar `k` nije u intervalu [1, M], parametar
        `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `np.linalg.eig(...)` ne hvataju se.

    Vidi također
    ------------
    bt_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 0, 1],
    ...      [0, 0, 1, 0],
    ...      [0, 0, 0, 1],
    ...      [0, 0, 0, 0]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X |= X.T
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 0, 1],
           [0, 0, 1, 0],
           [0, 1, 0, 1],
           [1, 0, 1, 0]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[0.6, 0.4, 0.8, 1.2],
           [0.4, 0.6, 1.2, 0.8],
           [0.8, 1.2, 1.4, 1.6],
           [1.2, 0.8, 1.6, 1.4]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[-0.05 , -0.978, -1.003, -0.051],
           [-0.978, -0.05 , -0.051, -1.003],
           [-1.003, -0.051, -1.052, -1.028],
           [-0.051, -1.003, -1.028, -1.052]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[0.524, 0.647, 0.847, 1.047],
           [0.647, 0.524, 1.047, 0.847],
           [0.847, 1.047, 1.371, 1.694],
           [1.047, 0.847, 1.694, 1.371]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[-0.462, -0.293, -0.748, -0.474],
           [-0.293, -0.462, -0.474, -0.748],
           [-0.748, -0.474, -1.21 , -0.767],
           [-0.474, -0.748, -0.767, -1.21 ]])

    Katzova ocijena neusmjerenog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X += X.T
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X.round(3)
    array([[-0.   ,  0.   , -0.   , -1.   ],
           [ 0.   ,  0.   ,  0.286,  0.   ],
           [-0.   ,  0.286, -0.   , -0.143],
           [-1.   ,  0.   , -0.143,  0.   ]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[ 0.336,  0.007,  0.049, -0.671],
           [ 0.007,  0.021,  0.147, -0.014],
           [ 0.049,  0.147,  0.028, -0.098],
           [-0.671, -0.014, -0.098,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 33.541,   1.447,   5.195, -34.401],
           [  1.447,   0.147,   0.526,  -1.484],
           [  5.195,   0.526,   0.889,  -5.328],
           [-34.401,  -1.484,  -5.328,  34.283]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[ 0.335,  0.029,  0.052, -0.67 ],
           [ 0.029,  0.001,  0.005, -0.015],
           [ 0.052,  0.005,  0.008, -0.104],
           [-0.67 , -0.015, -0.104,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 33.539,   1.493,   5.207, -34.399],
           [  1.493,   0.065,   0.232,  -1.488],
           [  5.207,   0.232,   0.808,  -5.341],
           [-34.399,  -1.488,  -5.341,  34.283]])

    Katzova ocijena neusmjerenog grafa s težinama.

    &gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; gamma.round(3)
    array([-0.336,  1.022])
    &gt;&gt;&gt; W.round(3)
    array([[-0.699,  0.699],
           [ 0.031,  0.031],
           [-0.108,  0.108],
           [-0.706, -0.706]])

    Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == W_k @ np.diag(gamma_k) @ W_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if X.shape[0] != X.shape[1]:
        raise ValueError(&#39;X mora biti kvadratna matrica.&#39;)
    if not _np.array_equal(X, X.T):
        raise ValueError(&#39;X mora biti simetricna matrica.&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1).&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti dimenzije matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    l, W = _np.linalg.eig(X)
    I = _np.flip(_np.argsort(_np.abs(l))).copy(order = &#39;F&#39;)
    l = _np.array(l[I], copy = True, order = &#39;F&#39;)
    W = _np.array(W[:, I], copy = True, order = &#39;F&#39;)
    del I
    if k is None:
        k = (
            1 if _np.isclose(1.0, 1.0 + l[0])
                else int((~_np.isclose(1.0, 1.0 + l / l[0])).sum())
        )
    l = l[:k].copy(order = &#39;F&#39;)
    W = W[:, :k].copy(order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        ((1.0 - beta * l) ** -1 - 1.0).copy(order = &#39;F&#39;) * W,
        W.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else ((1.0 - beta * l) ** -1 - 1.0, W)

def bt_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated bipartite Katz score* matrice bliskosti.

    *Bipartite truncated Katz score* se računa po formuli iz
    [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica bliskosti težinskog bipartitnog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.  Budući da su po pretpostavci
        kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
        osobe, a stupci konferencije), simetričnost matrice `X` ne znači
        simetričnost grafa.  Za Katzovu ocijenu neusmjerenog grafa koristi
        se `t_Katz_score`.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    psi_m_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_m_k[i]` iznosi
        `beta * s[i] / (1.0 - beta ** 2 * s[i] ** 2)`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    psi_p_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_p_k[i]` iznosi
        `(1.0 - beta ** 2 * s[i] ** 2) ** -1 - 1.0`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `beta` nije u intervalu (0, 1),
        parametar `k` nije u intervalu [1, M], parametar `compute` nije
        laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Vidi također
    ------------
    t_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 1, 1],
    ...      [1, 0, 0, 1],
    ...      [0, 1, 1, 1]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 1, 1],
           [1, 0, 0, 1],
           [0, 1, 1, 1]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.545, -0.909, -1.091, -1.636],
           [ 0.364, -0.727, -1.273, -0.909],
           [-0.727, -0.545, -1.455, -2.182]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 0.057, -0.98 , -0.054,  0.003],
           [-2.356,  1.151,  1.208, -1.148],
           [ 1.151, -0.111, -1.091,  0.06 ]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.476, -0.653, -1.201, -1.677],
           [ 0.351, -0.776, -1.252, -0.901],
           [-0.776, -0.724, -1.378, -2.153]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 0.255, -0.246, -0.369, -0.114],
           [-2.393,  1.012,  1.267, -1.126],
           [ 1.012, -0.625, -0.87 ,  0.142]])

    Katzova ocijena bipartitnog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X
    array([[-0.   ,  0.   , -0.25 ,  0.125],
           [-1.   ,  0.   , -0.   ,  0.125],
           [-0.   ,  0.5  , -0.25 ,  0.125]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.003,  0.005, -0.13 ,  0.065],
           [-0.67 ,  0.001, -0.001,  0.084],
           [-0.003,  0.272, -0.139,  0.07 ]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ -0.516,   0.063,  -0.3  ,   0.214],
           [-28.756,   0.338,  -0.298,   3.744],
           [ -0.676,   0.723,  -0.393,   0.281]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.008,  0.072, -0.047,  0.024],
           [-0.67 ,  0.001, -0.002,  0.085],
           [-0.001,  0.253, -0.163,  0.082]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ -0.527,   0.199,  -0.13 ,   0.131],
           [-28.756,   0.337,  -0.3  ,   3.745],
           [ -0.673,   0.684,  -0.442,   0.305]])

    Katzova ocijena bipartitnog grafa s težinama.

    &gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[ 0.019, -0.275],
           [ 1.   ,  0.029],
           [ 0.025, -0.961]])
    &gt;&gt;&gt; psi_m.round(3)
    array([0.676, 0.324])
    &gt;&gt;&gt; psi_p.round(3)
    array([0.341, 0.096])
    &gt;&gt;&gt; V.round(3)
    array([[-0.991, -0.049],
           [ 0.012, -0.812],
           [-0.011,  0.522],
           [ 0.129, -0.255]])

    Dekompozicija Katzove ocijene bipartitnog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == U_k @ np.diag(psi_m_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1].&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(min(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        (beta * s * (1.0 - beta ** 2 * s ** 2) ** -1).copy(order = &#39;F&#39;) * U,
        V.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else (
        U,
        beta * s * (1.0 - beta ** 2 * s ** 2) ** -1,
        (1.0 - beta ** 2 * s ** 2) ** -1 - 1.0,
        V
    )

def cp_score (Z, k = None, T0 = None, predict = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *CP score* tenzora.

    *CP score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CP score* računa.

    k : None or int in range [1, min(Z.shape)], optional
        Rang komponenti u dekompoziciji tenzora `Z` (zadana vrijednost je
        `None`).  Ako je None, uzima se `k = min(Z.shape)`.

    T0 : None or int in range [1, +inf), optional
        Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
        stanja (zadana vrijednost je `None`).  Ako je `None`, uzima se
        `T0 = Z.shape[-1]`.

    predict : None or callable, optional
        Funkcija za predviđanje sljedećih stanja (zadana vrijednost je `None`).
        Ako nije `None`, funkcija prima komponentu kao objekt klase
        `numpy.ndarray` oblika `(T0, k)`, a povratna vrijednost mora biti
        također `numpy.array` oblika `(k,)` ili `(n, k)` za neki `n &gt; 0`
        (predviđa se `n` sljedećih stanja).  Ako je `None`, uzima se aritmetička
        sredina po prvoj dimenziji.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija *CP* ocijene matrice
        tenzora `Z`; inače je povratna vrijednost *CP* ocijena tenzora `Z`
        (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Z_score : array
        *CP* ocijena zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je
        za 1 manje od tenzora `Z` ako `predict` predviđa točno jedno stanje, a
        inače je dimenzionalnosti iste kao `Z`.  Prvih `Z.ndim - 1` dimenzija
        jednakih je kao tenzora `Z`, a, ako `predict` predviđa `n &gt; 1` stanja,
        posljednja dimenzija je veličine `n`.  Ako je predikcija array oblika
        () ili (1,), povratna vrijednost je skalar.  Ova se povratna vrijednost
        vraća ako je `compute` istina.

    l : (Z.ndim,) array
        Dekomponiramo li tenzor `Z` na tenzore `cp_components` ranga `k` tako da
        je `j`-ti stupac svake komponente normiran, onda je
        `Z = sum(l[i] * prod(cp_components[:, i]))`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    cpd : tuple of arrays
        `cpd` je `tuple` duljine `Z.ndim - 1`, a `cpd[i]` je, kao
        `numpy.ndarray` oblika `(Z.shape[i], k)`, `i`-ta komponenta u *CP*
        dekompoziciji tenzora `Z` na komponente ranga `k`; dodatno, norma svakog
        stupca matrice `cpd[i]` iznosi `1`.  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    p : array
        Rezultat predikcije funkcijom `predict`.  Ako je predikcija rezultirala
        jednodimenzionalnim nizom, `p` će ipak biti dvodimenzionalan (druga
        dimenzija je veličine 1).  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `T0` nije cijeli broj, parametar `predict` nema
        metodu `__call__`, parametar `compute` nije istinitosna vrijednost,
        predikcija nije tenzor numeričkih vrijednosti.

    ValueError
        Parametar `Z` je prazni tenzor ili sadrži nedefinirane ili beskonačne
        vrijednosti, parametar `k` nije u intervalu [1, `min(Z.shape)`],
        parametar `T0` nije strogo pozitivan, parametar `compute` nije
        laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.

    other
        Iznimke izbačene pozivom `tl.decomposition.parafac(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cp_score(Z).round(3)
    array([[ 1.503,  3.5  ,  5.497,  7.494],
           [ 9.502, 11.5  , 13.499, 15.498],
           [17.5  , 19.5  , 21.501, 23.502]])
    &gt;&gt;&gt; cp_score(Z, k = 1).round(3)
    array([[ 3.836,  4.433,  5.031,  5.628],
           [10.188, 11.775, 13.362, 14.949],
           [16.54 , 19.116, 21.693, 24.269]])
    &gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
    array([[ 2.061,  4.009,  5.957,  7.905],
           [ 9.982, 11.99 , 13.998, 16.005],
           [17.904, 19.971, 22.038, 24.105]])
    &gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
    array([[ 3.955,  4.571,  5.187,  5.803],
           [10.504, 12.14 , 13.776, 15.412],
           [17.053, 19.709, 22.365, 25.021]])

    *CP* ocijena tenzora.

    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
    array([[-21.019, -22.13 , -23.241, -24.352],
           [-29.51 , -32.583, -35.657, -38.73 ],
           [-38.001, -43.037, -48.073, -53.109]])
    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
    array([[[-21.019,  -3.169],
            [-22.13 ,  -0.827],
            [-23.241,   1.515],
            [-24.352,   3.858]],
           [[-29.51 ,   5.224],
            [-32.583,   7.089],
            [-35.657,   8.954],
            [-38.73 ,  10.819]],
           [[-38.001,  13.617],
            [-43.037,  15.005],
            [-48.073,  16.393],
            [-53.109,  17.78 ]]])

    Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
    promjenom parametra `predict` i mijenjanja količine stanja koja se
    predviđaju.  Prije svakog poziva postavlja se *sjeme* generatora
    pseudo-slučajnih brojeva u biblioteci *NumPy*-ja zato da primjeri budu
    reproducibilni.

    &gt;&gt;&gt; def sqmean (X):
    ...     return np.sqrt(np.mean(np.square(X), axis = 0))
    ...
    &gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
    array([[ -1.494,  -3.493,  -5.493,  -7.493],
           [ -9.5  , -11.501, -13.501, -15.502],
           [-17.507, -19.508, -21.51 , -23.511]])

    Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
    primjer mogao realizirati također koristeći `lambda` funkciju).

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if (_np.isnan(Z) | _np.isinf(Z)).any():
        raise ValueError(
            &#39;Z mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(Z.shape):
            raise ValueError(
                &#39;k ne smije nadmasiti najmanju dimenziju tenzora Z.&#39;
            )

    # Saniraj parametar T0.
    if T0 is not None:
        if not isinstance(T0, _numbers.Integral):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        try:
            T0 = _copy.deepcopy(int(T0))
        except (TypeError, ValueError):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        if T0 &lt;= 0:
            raise ValueError(&#39;T0 mora biti strogo pozitivan.&#39;)
        T0 = min(T0, int(Z.shape[-1]))

    # Saniraj parametar predict.
    if predict is None:
        predict = _functools.partial(_np.mean, axis = 0, keepdims = False)
    if not hasattr(predict, &#39;__call__&#39;):
        raise TypeError(
            &#39;Nacin predikcije mora biti zadan funkcijskim objektom.&#39;
        )

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj CP dekompoziciju tenzora Z.
    cpd = _copy.deepcopy(
        list(_parafac(Z, int(min(Z.shape)) if k is None else k))
    )
    l = _np.ones(min(Z.shape) if k is None else k, dtype = float, order = &#39;F&#39;)
    for i in iter(range(int(Z.ndim))):
        cpd[i] = _np.array(cpd[i], copy = True, order = &#39;F&#39;)
        if cpd[i].ndim &lt;= 1:
            cpd[i] = cpd[i].reshape((cpd[i].size, 1)).copy(order = &#39;F&#39;)
        for k in iter(range(int(l.size))):
            aux_N = _np.linalg.norm(cpd[i][:, k])
            l[k] *= aux_N
            cpd[i][:, k] /= aux_N
            del aux_N

    # Predvidi vrijednosti posljednje komponente.
    if T0 is not None:
        cpd[-1] = cpd[-1][int(Z.shape[-1] - T0):].copy(order = &#39;F&#39;)
    cpd[-1] = predict(cpd[-1])

    # Saniraj predikciju posljednje komponente.
    if not isinstance(cpd[-1], _np.ndarray):
        if not (hasattr(cpd[-1], &#39;__iter__&#39;) or hasattr(cpd[-1], &#39;__array__&#39;)):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
        try:
            cpd[-1] = _np.array(cpd[-1])
        except (TypeError, ValueError):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        cpd[-1].dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Predikcija mora biti tenzor numerickih vrijednosti.&#39;)
    if cpd[-1].ndim not in {1, 2}:
        raise ValueError(
            &#39;Predikcija mora biti jednodimenzionalna ili dvodimenzionalna.&#39;
        )
    if not cpd[-1].size:
        raise ValueError(&#39;Predikcija ne smije biti prazna.&#39;)
    if isinstance(cpd[-1], _np.matrix):
        cpd[-1] = cpd[-1].A
    if cpd[-1].ndim == 2:
        cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
    else:
        cpd[-1]= cpd[-1].reshape((cpd[-1].size, 1)).copy(order = &#39;C&#39;)
    if cpd[-1].shape[0] != l.size:
        raise ValueError(&#39;Predikcija mora biti koliko i komponenti.&#39;)

    # Konvertiraj objekt cpd u tuple.
    cpd = tuple(cpd)

    # Ako se ne traži rekompozicija predikcije, vrati njezinu dekompoziciju.
    if not compute:
        return (l, _copy.deepcopy(cpd[:-1]), cpd[-1].T.copy(order = &#39;F&#39;))

    # Izračunaj rekompoziciju predikcije.
    # TODO: Ubrzati ovaj dio koda NumPy-jevim &#34;broadcastingom&#34;.
    aux_dim = _np.ones(max(Z.ndim - 1, 0), dtype = int, order = &#39;F&#39;)
    S = _np.zeros(
        tuple(_np.concatenate((Z.shape[:-1], [cpd[-1].shape[1]])).tolist()),
        dtype = float,
        order = &#39;F&#39;
    )
    for k in iter(range(int(l.size))):
        aux_S = l[k] * cpd[-1][k].ravel()
        aux_S = aux_S.reshape(
            tuple(_np.concatenate((aux_dim, [aux_S.size])).tolist())
        )
        for i in iter(range(int(Z.ndim - 1))):
            aux_S = (
                aux_S * cpd[i][:, k].reshape(
                    tuple(
                        _np.concatenate(([Z.shape[i]], aux_dim[i:])).tolist()
                    )
                )
            )
        S = S + aux_S
        del aux_S
    del aux_dim

    # Po potrebi redimenzioniraj predikciju ili ju pretvori u skalar.
    if isinstance(S, _np.ndarray):
        if S.shape == tuple():
            S = S.dtype.type(S)
        elif S.shape[-1] == 1:
            S = S.reshape(S.shape[:-1]).copy(order = &#39;F&#39;)
            if S.shape == tuple():
                S = S.dtype.type(S)
        else:
            S = S.copy(order = &#39;F&#39;)

    # Vrati izračunatu predikciju.
    return S</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tlp.bt_Katz_score"><code class="name flex">
<span>def <span class="ident">bt_Katz_score</span></span>(<span>X, beta=0.5, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated bipartite Katz score</em> matrice bliskosti.</p>
<p><em>Bipartite truncated Katz score</em> se računa po formuli iz
<a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Matrica bliskosti težinskog bipartitnog grafa.
Sve veze moraju imati
definiranu i konačnu težinu (težina je 0 ako veze nema).
Graf s vezama
bez težina realizira se vezama težine 1.
Budući da su po pretpostavci
kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
osobe, a stupci konferencije), simetričnost matrice <code>X</code> ne znači
simetričnost grafa.
Za Katzovu ocijenu neusmjerenog grafa koristi
se <a title="tlp.t_Katz_score" href="#tlp.t_Katz_score"><code>t_Katz_score()</code></a>.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> (<code>0</code>, <code>1</code>), optional</dt>
<dd>Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>M</code>, <code>N</code>)], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
bliskosti <code>X</code>; inače je povratna vrijednost Katzova ocijena matrice
bliskosti <code>X</code> (zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Score_k</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Katzova ocijena matrice bliskosti <code>X</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> istina.</dd>
<dt><strong><code>U_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
<dt><strong><code>psi_m_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>s</code> singularnih vrijednosti matrice <code>X</code> poredan silazno,
<code>psi_m_k[i]</code> iznosi
<code>beta * s[i] / (1.0 - beta ** 2 * s[i] ** 2)</code>.
Ova se povratna
vrijednost vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>psi_p_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>s</code> singularnih vrijednosti matrice <code>X</code> poredan silazno,
<code>psi_p_k[i]</code> iznosi
<code>(1.0 - beta ** 2 * s[i] ** 2) ** -1 - 1.0</code>.
Ova se povratna
vrijednost vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>V_k</code></strong> :&ensp;(<code>N</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>beta</code> nije
realni broj, parametar <code>k</code> nije cijeli broj, parametar <code>compute</code> nije
istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije matrica, sadrži nedefinirane ili
beskonačne vrijednosti, parametar <code>beta</code> nije u intervalu (0, 1),
parametar <code>k</code> nije u intervalu [1, M], parametar <code>compute</code> nije
laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.partial_svd(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="vidi-takoer">Vidi također</h2>
<dl>
<dt><strong><code>t_Katz_score</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[0, 0, 1, 1],
...      [1, 0, 0, 1],
...      [0, 1, 1, 1]]
&gt;&gt;&gt; X = np.array(X, dtype = bool)
&gt;&gt;&gt; X.astype(int)
array([[0, 0, 1, 1],


   [1, 0, 0, 1],
   [0, 1, 1, 1]])

&gt;&gt;&gt; bt_Katz_score(X).round(3)
array([[-0.545, -0.909, -1.091, -1.636],


   [ 0.364, -0.727, -1.273, -0.909],
   [-0.727, -0.545, -1.455, -2.182]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
array([[ 0.057, -0.98 , -0.054,  0.003],


   [-2.356,  1.151,  1.208, -1.148],
   [ 1.151, -0.111, -1.091,  0.06 ]])

&gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
array([[-0.476, -0.653, -1.201, -1.677],


   [ 0.351, -0.776, -1.252, -0.901],
   [-0.776, -0.724, -1.378, -2.153]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ 0.255, -0.246, -0.369, -0.114],


   [-2.393,  1.012,  1.267, -1.126],
   [ 1.012, -0.625, -0.87 ,  0.142]])
</code></pre>
<p>Katzova ocijena bipartitnog grafa bez težina.</p>
<pre><code>&gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
&gt;&gt;&gt; X /= np.abs(X).max()
&gt;&gt;&gt; X
array([[-0.   ,  0.   , -0.25 ,  0.125],


   [-1.   ,  0.   , -0.   ,  0.125],
   [-0.   ,  0.5  , -0.25 ,  0.125]])

&gt;&gt;&gt; bt_Katz_score(X).round(3)
array([[-0.003,  0.005, -0.13 ,  0.065],


   [-0.67 ,  0.001, -0.001,  0.084],
   [-0.003,  0.272, -0.139,  0.07 ]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
array([[ -0.516,   0.063,  -0.3  ,   0.214],


   [-28.756,   0.338,  -0.298,   3.744],
   [ -0.676,   0.723,  -0.393,   0.281]])

&gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
array([[-0.008,  0.072, -0.047,  0.024],


   [-0.67 ,  0.001, -0.002,  0.085],
   [-0.001,  0.253, -0.163,  0.082]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ -0.527,   0.199,  -0.13 ,   0.131],


   [-28.756,   0.337,  -0.3  ,   3.745],
   [ -0.673,   0.684,  -0.442,   0.305]])
</code></pre>
<p>Katzova ocijena bipartitnog grafa s težinama.</p>
<pre><code>&gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
&gt;&gt;&gt; U.round(3)
array([[ 0.019, -0.275],


   [ 1.   ,  0.029],
   [ 0.025, -0.961]])

&gt;&gt;&gt; psi_m.round(3)
array([0.676, 0.324])
&gt;&gt;&gt; psi_p.round(3)
array([0.341, 0.096])
&gt;&gt;&gt; V.round(3)
array([[-0.991, -0.049],


   [ 0.012, -0.812],
   [-0.011,  0.522],
   [ 0.129, -0.255]])
</code></pre>
<p>Dekompozicija Katzove ocijene bipartitnog grafa s težinama.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>score_k == U_k @ np.diag(psi_m_k) @ V_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def bt_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated bipartite Katz score* matrice bliskosti.

    *Bipartite truncated Katz score* se računa po formuli iz
    [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica bliskosti težinskog bipartitnog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.  Budući da su po pretpostavci
        kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
        osobe, a stupci konferencije), simetričnost matrice `X` ne znači
        simetričnost grafa.  Za Katzovu ocijenu neusmjerenog grafa koristi
        se `t_Katz_score`.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    psi_m_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_m_k[i]` iznosi
        `beta * s[i] / (1.0 - beta ** 2 * s[i] ** 2)`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    psi_p_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_p_k[i]` iznosi
        `(1.0 - beta ** 2 * s[i] ** 2) ** -1 - 1.0`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `beta` nije u intervalu (0, 1),
        parametar `k` nije u intervalu [1, M], parametar `compute` nije
        laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Vidi također
    ------------
    t_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 1, 1],
    ...      [1, 0, 0, 1],
    ...      [0, 1, 1, 1]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 1, 1],
           [1, 0, 0, 1],
           [0, 1, 1, 1]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.545, -0.909, -1.091, -1.636],
           [ 0.364, -0.727, -1.273, -0.909],
           [-0.727, -0.545, -1.455, -2.182]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 0.057, -0.98 , -0.054,  0.003],
           [-2.356,  1.151,  1.208, -1.148],
           [ 1.151, -0.111, -1.091,  0.06 ]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.476, -0.653, -1.201, -1.677],
           [ 0.351, -0.776, -1.252, -0.901],
           [-0.776, -0.724, -1.378, -2.153]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 0.255, -0.246, -0.369, -0.114],
           [-2.393,  1.012,  1.267, -1.126],
           [ 1.012, -0.625, -0.87 ,  0.142]])

    Katzova ocijena bipartitnog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X
    array([[-0.   ,  0.   , -0.25 ,  0.125],
           [-1.   ,  0.   , -0.   ,  0.125],
           [-0.   ,  0.5  , -0.25 ,  0.125]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.003,  0.005, -0.13 ,  0.065],
           [-0.67 ,  0.001, -0.001,  0.084],
           [-0.003,  0.272, -0.139,  0.07 ]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ -0.516,   0.063,  -0.3  ,   0.214],
           [-28.756,   0.338,  -0.298,   3.744],
           [ -0.676,   0.723,  -0.393,   0.281]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.008,  0.072, -0.047,  0.024],
           [-0.67 ,  0.001, -0.002,  0.085],
           [-0.001,  0.253, -0.163,  0.082]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ -0.527,   0.199,  -0.13 ,   0.131],
           [-28.756,   0.337,  -0.3  ,   3.745],
           [ -0.673,   0.684,  -0.442,   0.305]])

    Katzova ocijena bipartitnog grafa s težinama.

    &gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[ 0.019, -0.275],
           [ 1.   ,  0.029],
           [ 0.025, -0.961]])
    &gt;&gt;&gt; psi_m.round(3)
    array([0.676, 0.324])
    &gt;&gt;&gt; psi_p.round(3)
    array([0.341, 0.096])
    &gt;&gt;&gt; V.round(3)
    array([[-0.991, -0.049],
           [ 0.012, -0.812],
           [-0.011,  0.522],
           [ 0.129, -0.255]])

    Dekompozicija Katzove ocijene bipartitnog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == U_k @ np.diag(psi_m_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1].&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(min(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        (beta * s * (1.0 - beta ** 2 * s ** 2) ** -1).copy(order = &#39;F&#39;) * U,
        V.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else (
        U,
        beta * s * (1.0 - beta ** 2 * s ** 2) ** -1,
        (1.0 - beta ** 2 * s ** 2) ** -1 - 1.0,
        V
    )</code></pre>
</details>
</dd>
<dt id="tlp.cp_score"><code class="name flex">
<span>def <span class="ident">cp_score</span></span>(<span>Z, k=None, T0=None, predict=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>CP score</em> tenzora.</p>
<p><em>CP score</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>array</code></dt>
<dd>Tenzor numeričkih vrijednosti čiji se <em>CP score</em> računa.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>Z.shape</code>)], optional</dt>
<dd>Rang komponenti u dekompoziciji tenzora <code>Z</code> (zadana vrijednost je
<code>None</code>).
Ako je None, uzima se <code>k = min(Z.shape)</code>.</dd>
<dt><strong><code>T0</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, +<code>inf</code>), optional</dt>
<dd>Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
stanja (zadana vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se
<code>T0 = Z.shape[-1]</code>.</dd>
<dt><strong><code>predict</code></strong> :&ensp;<code>None</code> or <code>callable</code>, optional</dt>
<dd>Funkcija za predviđanje sljedećih stanja (zadana vrijednost je <code>None</code>).
Ako nije <code>None</code>, funkcija prima komponentu kao objekt klase
<code>numpy.ndarray</code> oblika <code>(T0, k)</code>, a povratna vrijednost mora biti
također <code>numpy.array</code> oblika <code>(k,)</code> ili <code>(n, k)</code> za neki <code>n &gt; 0</code>
(predviđa se <code>n</code> sljedećih stanja).
Ako je <code>None</code>, uzima se aritmetička
sredina po prvoj dimenziji.</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija <em>CP</em> ocijene matrice
tenzora <code>Z</code>; inače je povratna vrijednost <em>CP</em> ocijena tenzora <code>Z</code>
(zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Z_score</code></strong> :&ensp;<code>array</code></dt>
<dd><em>CP</em> ocijena zadanog tenzora <code>Z</code>.
Povratni tenzor dimenzionalnosti je
za 1 manje od tenzora <code>Z</code> ako <code>predict</code> predviđa točno jedno stanje, a
inače je dimenzionalnosti iste kao <code>Z</code>.
Prvih <code>Z.ndim - 1</code> dimenzija
jednakih je kao tenzora <code>Z</code>, a, ako <code>predict</code> predviđa <code>n &gt; 1</code> stanja,
posljednja dimenzija je veličine <code>n</code>.
Ako je predikcija array oblika
() ili (1,), povratna vrijednost je skalar.
Ova se povratna vrijednost
vraća ako je <code>compute</code> istina.</dd>
<dt><strong><code>l</code></strong> :&ensp;(<code>Z.ndim</code>,) <code>array</code></dt>
<dd>Dekomponiramo li tenzor <code>Z</code> na tenzore <code>cp_components</code> ranga <code>k</code> tako da
je <code>j</code>-ti stupac svake komponente normiran, onda je
<code>Z = sum(l[i] * prod(cp_components[:, i]))</code>.
Ova se povratna vrijednost
vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>cpd</code></strong> :&ensp;<code>tuple</code> of <code>arrays</code></dt>
<dd><code>cpd</code> je <code>tuple</code> duljine <code>Z.ndim - 1</code>, a <code>cpd[i]</code> je, kao
<code>numpy.ndarray</code> oblika <code>(Z.shape[i], k)</code>, <code>i</code>-ta komponenta u <em>CP</em>
dekompoziciji tenzora <code>Z</code> na komponente ranga <code>k</code>; dodatno, norma svakog
stupca matrice <code>cpd[i]</code> iznosi <code>1</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> laž.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>array</code></dt>
<dd>Rezultat predikcije funkcijom <code>predict</code>.
Ako je predikcija rezultirala
jednodimenzionalnim nizom, <code>p</code> će ipak biti dvodimenzionalan (druga
dimenzija je veličine 1).
Ova se povratna vrijednost vraća ako je
<code>compute</code> laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>Z</code> nije tenzor numeričkih vrijednosti, parametar <code>k</code> nije
cijeli broj, parametar <code>T0</code> nije cijeli broj, parametar <code>predict</code> nema
metodu <code>__call__</code>, parametar <code>compute</code> nije istinitosna vrijednost,
predikcija nije tenzor numeričkih vrijednosti.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>Z</code> je prazni tenzor ili sadrži nedefinirane ili beskonačne
vrijednosti, parametar <code>k</code> nije u intervalu [1, <code>min(Z.shape)</code>],
parametar <code>T0</code> nije strogo pozitivan, parametar <code>compute</code> nije
laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.decomposition.parafac(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; Z = [[[ 1,  2],
...       [ 3,  4],
...       [ 5,  6],
...       [ 7,  8]],
...      [[ 9, 10],
...       [11, 12],
...       [13, 14],
...       [15, 16]],
...      [[17, 18],
...       [19, 20],
...       [21, 22],
...       [23, 24]]]
&gt;&gt;&gt; cp_score(Z).round(3)
array([[ 1.503,  3.5  ,  5.497,  7.494],


   [ 9.502, 11.5  , 13.499, 15.498],
   [17.5  , 19.5  , 21.501, 23.502]])

&gt;&gt;&gt; cp_score(Z, k = 1).round(3)
array([[ 3.836,  4.433,  5.031,  5.628],


   [10.188, 11.775, 13.362, 14.949],
   [16.54 , 19.116, 21.693, 24.269]])

&gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
array([[ 2.061,  4.009,  5.957,  7.905],


   [ 9.982, 11.99 , 13.998, 16.005],
   [17.904, 19.971, 22.038, 24.105]])

&gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
array([[ 3.955,  4.571,  5.187,  5.803],


   [10.504, 12.14 , 13.776, 15.412],
   [17.053, 19.709, 22.365, 25.021]])
</code></pre>
<p><em>CP</em> ocijena tenzora.</p>
<pre><code>&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
array([[-21.019, -22.13 , -23.241, -24.352],


   [-29.51 , -32.583, -35.657, -38.73 ],
   [-38.001, -43.037, -48.073, -53.109]])

&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
array([[[-21.019,  -3.169],


    [-22.13 ,  -0.827],
    [-23.241,   1.515],
    [-24.352,   3.858]],
   [[-29.51 ,   5.224],
    [-32.583,   7.089],
    [-35.657,   8.954],
    [-38.73 ,  10.819]],
   [[-38.001,  13.617],
    [-43.037,  15.005],
    [-48.073,  16.393],
    [-53.109,  17.78 ]]])
</code></pre>
<p>Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
promjenom parametra <code>predict</code> i mijenjanja količine stanja koja se
predviđaju.
Prije svakog poziva postavlja se <em>sjeme</em> generatora
pseudo-slučajnih brojeva u biblioteci <em>NumPy</em>-ja zato da primjeri budu
reproducibilni.</p>
<pre><code>&gt;&gt;&gt; def sqmean (X):
...     return np.sqrt(np.mean(np.square(X), axis = 0))
...
&gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
array([[ -1.494,  -3.493,  -5.493,  -7.493],


   [ -9.5  , -11.501, -13.501, -15.502],
   [-17.507, -19.508, -21.51 , -23.511]])
</code></pre>
<p>Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
primjer mogao realizirati također koristeći <code>lambda</code> funkciju).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cp_score (Z, k = None, T0 = None, predict = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *CP score* tenzora.

    *CP score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CP score* računa.

    k : None or int in range [1, min(Z.shape)], optional
        Rang komponenti u dekompoziciji tenzora `Z` (zadana vrijednost je
        `None`).  Ako je None, uzima se `k = min(Z.shape)`.

    T0 : None or int in range [1, +inf), optional
        Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
        stanja (zadana vrijednost je `None`).  Ako je `None`, uzima se
        `T0 = Z.shape[-1]`.

    predict : None or callable, optional
        Funkcija za predviđanje sljedećih stanja (zadana vrijednost je `None`).
        Ako nije `None`, funkcija prima komponentu kao objekt klase
        `numpy.ndarray` oblika `(T0, k)`, a povratna vrijednost mora biti
        također `numpy.array` oblika `(k,)` ili `(n, k)` za neki `n &gt; 0`
        (predviđa se `n` sljedećih stanja).  Ako je `None`, uzima se aritmetička
        sredina po prvoj dimenziji.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija *CP* ocijene matrice
        tenzora `Z`; inače je povratna vrijednost *CP* ocijena tenzora `Z`
        (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Z_score : array
        *CP* ocijena zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je
        za 1 manje od tenzora `Z` ako `predict` predviđa točno jedno stanje, a
        inače je dimenzionalnosti iste kao `Z`.  Prvih `Z.ndim - 1` dimenzija
        jednakih je kao tenzora `Z`, a, ako `predict` predviđa `n &gt; 1` stanja,
        posljednja dimenzija je veličine `n`.  Ako je predikcija array oblika
        () ili (1,), povratna vrijednost je skalar.  Ova se povratna vrijednost
        vraća ako je `compute` istina.

    l : (Z.ndim,) array
        Dekomponiramo li tenzor `Z` na tenzore `cp_components` ranga `k` tako da
        je `j`-ti stupac svake komponente normiran, onda je
        `Z = sum(l[i] * prod(cp_components[:, i]))`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    cpd : tuple of arrays
        `cpd` je `tuple` duljine `Z.ndim - 1`, a `cpd[i]` je, kao
        `numpy.ndarray` oblika `(Z.shape[i], k)`, `i`-ta komponenta u *CP*
        dekompoziciji tenzora `Z` na komponente ranga `k`; dodatno, norma svakog
        stupca matrice `cpd[i]` iznosi `1`.  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    p : array
        Rezultat predikcije funkcijom `predict`.  Ako je predikcija rezultirala
        jednodimenzionalnim nizom, `p` će ipak biti dvodimenzionalan (druga
        dimenzija je veličine 1).  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `T0` nije cijeli broj, parametar `predict` nema
        metodu `__call__`, parametar `compute` nije istinitosna vrijednost,
        predikcija nije tenzor numeričkih vrijednosti.

    ValueError
        Parametar `Z` je prazni tenzor ili sadrži nedefinirane ili beskonačne
        vrijednosti, parametar `k` nije u intervalu [1, `min(Z.shape)`],
        parametar `T0` nije strogo pozitivan, parametar `compute` nije
        laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.

    other
        Iznimke izbačene pozivom `tl.decomposition.parafac(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cp_score(Z).round(3)
    array([[ 1.503,  3.5  ,  5.497,  7.494],
           [ 9.502, 11.5  , 13.499, 15.498],
           [17.5  , 19.5  , 21.501, 23.502]])
    &gt;&gt;&gt; cp_score(Z, k = 1).round(3)
    array([[ 3.836,  4.433,  5.031,  5.628],
           [10.188, 11.775, 13.362, 14.949],
           [16.54 , 19.116, 21.693, 24.269]])
    &gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
    array([[ 2.061,  4.009,  5.957,  7.905],
           [ 9.982, 11.99 , 13.998, 16.005],
           [17.904, 19.971, 22.038, 24.105]])
    &gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
    array([[ 3.955,  4.571,  5.187,  5.803],
           [10.504, 12.14 , 13.776, 15.412],
           [17.053, 19.709, 22.365, 25.021]])

    *CP* ocijena tenzora.

    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
    array([[-21.019, -22.13 , -23.241, -24.352],
           [-29.51 , -32.583, -35.657, -38.73 ],
           [-38.001, -43.037, -48.073, -53.109]])
    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
    array([[[-21.019,  -3.169],
            [-22.13 ,  -0.827],
            [-23.241,   1.515],
            [-24.352,   3.858]],
           [[-29.51 ,   5.224],
            [-32.583,   7.089],
            [-35.657,   8.954],
            [-38.73 ,  10.819]],
           [[-38.001,  13.617],
            [-43.037,  15.005],
            [-48.073,  16.393],
            [-53.109,  17.78 ]]])

    Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
    promjenom parametra `predict` i mijenjanja količine stanja koja se
    predviđaju.  Prije svakog poziva postavlja se *sjeme* generatora
    pseudo-slučajnih brojeva u biblioteci *NumPy*-ja zato da primjeri budu
    reproducibilni.

    &gt;&gt;&gt; def sqmean (X):
    ...     return np.sqrt(np.mean(np.square(X), axis = 0))
    ...
    &gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
    array([[ -1.494,  -3.493,  -5.493,  -7.493],
           [ -9.5  , -11.501, -13.501, -15.502],
           [-17.507, -19.508, -21.51 , -23.511]])

    Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
    primjer mogao realizirati također koristeći `lambda` funkciju).

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if (_np.isnan(Z) | _np.isinf(Z)).any():
        raise ValueError(
            &#39;Z mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(Z.shape):
            raise ValueError(
                &#39;k ne smije nadmasiti najmanju dimenziju tenzora Z.&#39;
            )

    # Saniraj parametar T0.
    if T0 is not None:
        if not isinstance(T0, _numbers.Integral):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        try:
            T0 = _copy.deepcopy(int(T0))
        except (TypeError, ValueError):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        if T0 &lt;= 0:
            raise ValueError(&#39;T0 mora biti strogo pozitivan.&#39;)
        T0 = min(T0, int(Z.shape[-1]))

    # Saniraj parametar predict.
    if predict is None:
        predict = _functools.partial(_np.mean, axis = 0, keepdims = False)
    if not hasattr(predict, &#39;__call__&#39;):
        raise TypeError(
            &#39;Nacin predikcije mora biti zadan funkcijskim objektom.&#39;
        )

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj CP dekompoziciju tenzora Z.
    cpd = _copy.deepcopy(
        list(_parafac(Z, int(min(Z.shape)) if k is None else k))
    )
    l = _np.ones(min(Z.shape) if k is None else k, dtype = float, order = &#39;F&#39;)
    for i in iter(range(int(Z.ndim))):
        cpd[i] = _np.array(cpd[i], copy = True, order = &#39;F&#39;)
        if cpd[i].ndim &lt;= 1:
            cpd[i] = cpd[i].reshape((cpd[i].size, 1)).copy(order = &#39;F&#39;)
        for k in iter(range(int(l.size))):
            aux_N = _np.linalg.norm(cpd[i][:, k])
            l[k] *= aux_N
            cpd[i][:, k] /= aux_N
            del aux_N

    # Predvidi vrijednosti posljednje komponente.
    if T0 is not None:
        cpd[-1] = cpd[-1][int(Z.shape[-1] - T0):].copy(order = &#39;F&#39;)
    cpd[-1] = predict(cpd[-1])

    # Saniraj predikciju posljednje komponente.
    if not isinstance(cpd[-1], _np.ndarray):
        if not (hasattr(cpd[-1], &#39;__iter__&#39;) or hasattr(cpd[-1], &#39;__array__&#39;)):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
        try:
            cpd[-1] = _np.array(cpd[-1])
        except (TypeError, ValueError):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        cpd[-1].dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Predikcija mora biti tenzor numerickih vrijednosti.&#39;)
    if cpd[-1].ndim not in {1, 2}:
        raise ValueError(
            &#39;Predikcija mora biti jednodimenzionalna ili dvodimenzionalna.&#39;
        )
    if not cpd[-1].size:
        raise ValueError(&#39;Predikcija ne smije biti prazna.&#39;)
    if isinstance(cpd[-1], _np.matrix):
        cpd[-1] = cpd[-1].A
    if cpd[-1].ndim == 2:
        cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
    else:
        cpd[-1]= cpd[-1].reshape((cpd[-1].size, 1)).copy(order = &#39;C&#39;)
    if cpd[-1].shape[0] != l.size:
        raise ValueError(&#39;Predikcija mora biti koliko i komponenti.&#39;)

    # Konvertiraj objekt cpd u tuple.
    cpd = tuple(cpd)

    # Ako se ne traži rekompozicija predikcije, vrati njezinu dekompoziciju.
    if not compute:
        return (l, _copy.deepcopy(cpd[:-1]), cpd[-1].T.copy(order = &#39;F&#39;))

    # Izračunaj rekompoziciju predikcije.
    # TODO: Ubrzati ovaj dio koda NumPy-jevim &#34;broadcastingom&#34;.
    aux_dim = _np.ones(max(Z.ndim - 1, 0), dtype = int, order = &#39;F&#39;)
    S = _np.zeros(
        tuple(_np.concatenate((Z.shape[:-1], [cpd[-1].shape[1]])).tolist()),
        dtype = float,
        order = &#39;F&#39;
    )
    for k in iter(range(int(l.size))):
        aux_S = l[k] * cpd[-1][k].ravel()
        aux_S = aux_S.reshape(
            tuple(_np.concatenate((aux_dim, [aux_S.size])).tolist())
        )
        for i in iter(range(int(Z.ndim - 1))):
            aux_S = (
                aux_S * cpd[i][:, k].reshape(
                    tuple(
                        _np.concatenate(([Z.shape[i]], aux_dim[i:])).tolist()
                    )
                )
            )
        S = S + aux_S
        del aux_S
    del aux_dim

    # Po potrebi redimenzioniraj predikciju ili ju pretvori u skalar.
    if isinstance(S, _np.ndarray):
        if S.shape == tuple():
            S = S.dtype.type(S)
        elif S.shape[-1] == 1:
            S = S.reshape(S.shape[:-1]).copy(order = &#39;F&#39;)
            if S.shape == tuple():
                S = S.dtype.type(S)
        else:
            S = S.copy(order = &#39;F&#39;)

    # Vrati izračunatu predikciju.
    return S</code></pre>
</details>
</dd>
<dt id="tlp.cwt"><code class="name flex">
<span>def <span class="ident">cwt</span></span>(<span>Z, theta=0.5, norm=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>collapsed weighted tensor</em> (<em>CWT</em>).</p>
<p><em>CWT</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>array</code></dt>
<dd>Tenzor numeričkih vrijednosti čiji se <em>CWT</em> računa.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> [<code>0</code> <code>to</code> <code>1</code>), optional</dt>
<dd>Parametar <em>gubitka</em> relevantnosti stanja kroz vrijeme (zadana vrijednost
je 0.5).</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
to jest, povratna vrijednost je podijeljena sa
<code>sum((1.0 - theta) ** i for i in range(Z.shape[-1]))</code> (zadana
vrijednost je laž).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd><em>CWT</em> zadanog tenzora <code>Z</code>.
Povratni tenzor dimenzionalnosti je za 1
manje od tenzora <code>Z</code>, a oblikom je jednak obliku <code>Z.shape[:-1]</code>.
Ako je
<code>Z</code> jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>Z</code> nije tenzor numeričkih vrijednosti, parametar <code>theta</code> nije
realni broj.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>Z</code> je skalar ili prazni tenzor, parametar <code>theta</code> nije u
intervalu [0, 1).</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; Z = [[[ 1,  2],
...       [ 3,  4],
...       [ 5,  6],
...       [ 7,  8]],
...      [[ 9, 10],
...       [11, 12],
...       [13, 14],
...       [15, 16]],
...      [[17, 18],
...       [19, 20],
...       [21, 22],
...       [23, 24]]]
&gt;&gt;&gt; cwt(Z)
array([[ 2.5,  5.5,  8.5, 11.5],


   [14.5, 17.5, 20.5, 23.5],
   [26.5, 29.5, 32.5, 35.5]])

&gt;&gt;&gt; cwt(Z, theta = 0.0)
array([[ 3.,  7., 11., 15.],


   [19., 23., 27., 31.],
   [35., 39., 43., 47.]])

&gt;&gt;&gt; cwt(Z, norm = True).round(3)
array([[ 1.667,  3.667,  5.667,  7.667],


   [ 9.667, 11.667, 13.667, 15.667],
   [17.667, 19.667, 21.667, 23.667]])

&gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
array([[ 1.5,  3.5,  5.5,  7.5],


   [ 9.5, 11.5, 13.5, 15.5],
   [17.5, 19.5, 21.5, 23.5]])
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cwt (Z, theta = 0.5, norm = False):
    &#34;&#34;&#34;
    Izračunaj *collapsed weighted tensor* (*CWT*).

    *CWT* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CWT* računa.

    theta : float in range [0 to 1), optional
        Parametar *gubitka* relevantnosti stanja kroz vrijeme (zadana vrijednost
        je 0.5).

    norm : boolean, optional
        Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
        to jest, povratna vrijednost je podijeljena sa
        `sum((1.0 - theta) ** i for i in range(Z.shape[-1]))` (zadana
        vrijednost je laž).

    Povratne vrijednosti
    --------------------
    array
        *CWT* zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je za 1
        manje od tenzora `Z`, a oblikom je jednak obliku `Z.shape[:-1]`.  Ako je
        `Z` jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `theta` nije
        realni broj.

    ValueError
        Parametar `Z` je skalar ili prazni tenzor, parametar `theta` nije u
        intervalu [0, 1).

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cwt(Z)
    array([[ 2.5,  5.5,  8.5, 11.5],
           [14.5, 17.5, 20.5, 23.5],
           [26.5, 29.5, 32.5, 35.5]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0)
    array([[ 3.,  7., 11., 15.],
           [19., 23., 27., 31.],
           [35., 39., 43., 47.]])
    &gt;&gt;&gt; cwt(Z, norm = True).round(3)
    array([[ 1.667,  3.667,  5.667,  7.667],
           [ 9.667, 11.667, 13.667, 15.667],
           [17.667, 19.667, 21.667, 23.667]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
    array([[ 1.5,  3.5,  5.5,  7.5],
           [ 9.5, 11.5, 13.5, 15.5],
           [17.5, 19.5, 21.5, 23.5]])

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar theta.
    if not isinstance(theta, _numbers.Real):
        raise TypeError(&#39;theta mora biti realni broj.&#39;)
    try:
        theta = _copy.deepcopy(float(theta))
    except (TypeError, ValueError):
        raise TypeError(&#39;theta mora biti klase float.&#39;)
    if _math.isnan(theta) or _math.isinf(theta):
        raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
    if not (theta &gt;= 0.0 and theta &lt; 1.0):
        raise ValueError(&#39;theta mora biti u intervalu [0, 1).&#39;)

    # Saniraj parametar norm.
    if not isinstance(
        norm,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)
    if norm not in {0, False, 1, True}:
        raise ValueError(&#39;norm mora biti laz/istina.&#39;)
    try:
        norm = _copy.deepcopy(bool(norm))
    except (TypeError, ValueError):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)

    # Izračunaj prvih Z.shape[-1] elemenata geometrijskog niza s koeficijentom
    # 1 - theta.
    one_min_theta = _np.flip(
        (1.0 - theta) ** _np.arange(Z.shape[-1], dtype = int)
    ).copy(order = &#39;F&#39;)

    # Izračunaj kompresijsku sumu.
    Z_compressed = (one_min_theta * Z).sum(axis = -1).copy(order = &#39;F&#39;)

    # Ako je norm istina, podijeli kompresijsku sumu sa _theta.sum().
    if norm:
        Z_compressed /= one_min_theta.sum()

    # Po potrebi pretvori Z u skalar.
    if isinstance(Z_compressed, _np.ndarray):
        if Z_compressed.shape == tuple():
            Z_compressed = Z_compressed.dtype.type(Z_compressed)

    # Vrati kompresijsku sumu.
    return Z_compressed</code></pre>
</details>
</dd>
<dt id="tlp.t_Katz_score"><code class="name flex">
<span>def <span class="ident">t_Katz_score</span></span>(<span>X, beta=0.5, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated Katz score</em> kvadratne simetrične matrice bliskosti.</p>
<p><em>Truncated Katz score</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>M</code>) <code>symmetric</code> <code>array</code></dt>
<dd>Matrica bliskosti neusmjerenog težinskog grafa.
Sve veze moraju imati
definiranu i konačnu težinu (težina je 0 ako veze nema).
Graf s vezama
bez težina realizira se vezama težine 1.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> (<code>0</code>, <code>1</code>), optional</dt>
<dd>Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>M</code>], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
bliskosti <code>X</code>; inače je povratna vrijednost Katzova ocijena matrice
bliskosti <code>X</code> (zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Score_k</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Katzova ocijena matrice bliskosti <code>X</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> istina.</dd>
<dt><strong><code>gamma_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>l</code> svojstvenih vrijednosti matrice <code>X</code> poredan silazno
po apsolutnoj vrijednosti, <code>gamma_k[i]</code> iznosi
<code>(1.0 - beta * l[i]) ** -1 - 1.0</code>.
Ova se povratna vrijednost vraća ako
je <code>compute</code> laž.</dd>
<dt><strong><code>W_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Matrica normiranih stupaca.
Ova se povratna vrijednost vraća ako je
<code>compute</code> laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>beta</code> nije
realni broj, parametar <code>k</code> nije cijeli broj, parametar <code>compute</code> nije
istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije kvadratna simetrična matrica,
sadrži nedefinirane ili beskonačne vrijednosti, parametar <code>beta</code> nije u
intervalu (0, 1), parametar <code>k</code> nije u intervalu [1, M], parametar
<code>compute</code> nije laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>np.linalg.eig(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="vidi-takoer">Vidi također</h2>
<dl>
<dt><strong><a title="tlp.bt_Katz_score" href="#tlp.bt_Katz_score"><code>bt_Katz_score()</code></a></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[0, 0, 0, 1],
...      [0, 0, 1, 0],
...      [0, 0, 0, 1],
...      [0, 0, 0, 0]]
&gt;&gt;&gt; X = np.array(X, dtype = bool)
&gt;&gt;&gt; X |= X.T
&gt;&gt;&gt; X.astype(int)
array([[0, 0, 0, 1],


   [0, 0, 1, 0],
   [0, 1, 0, 1],
   [1, 0, 1, 0]])

&gt;&gt;&gt; t_Katz_score(X).round(3)
array([[0.6, 0.4, 0.8, 1.2],


   [0.4, 0.6, 1.2, 0.8],
   [0.8, 1.2, 1.4, 1.6],
   [1.2, 0.8, 1.6, 1.4]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
array([[-0.05 , -0.978, -1.003, -0.051],


   [-0.978, -0.05 , -0.051, -1.003],
   [-1.003, -0.051, -1.052, -1.028],
   [-0.051, -1.003, -1.028, -1.052]])

&gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
array([[0.524, 0.647, 0.847, 1.047],


   [0.647, 0.524, 1.047, 0.847],
   [0.847, 1.047, 1.371, 1.694],
   [1.047, 0.847, 1.694, 1.371]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[-0.462, -0.293, -0.748, -0.474],


   [-0.293, -0.462, -0.474, -0.748],
   [-0.748, -0.474, -1.21 , -0.767],
   [-0.474, -0.748, -0.767, -1.21 ]])
</code></pre>
<p>Katzova ocijena neusmjerenog grafa bez težina.</p>
<pre><code>&gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
&gt;&gt;&gt; X += X.T
&gt;&gt;&gt; X /= np.abs(X).max()
&gt;&gt;&gt; X.round(3)
array([[-0.   ,  0.   , -0.   , -1.   ],


   [ 0.   ,  0.   ,  0.286,  0.   ],
   [-0.   ,  0.286, -0.   , -0.143],
   [-1.   ,  0.   , -0.143,  0.   ]])

&gt;&gt;&gt; t_Katz_score(X).round(3)
array([[ 0.336,  0.007,  0.049, -0.671],


   [ 0.007,  0.021,  0.147, -0.014],
   [ 0.049,  0.147,  0.028, -0.098],
   [-0.671, -0.014, -0.098,  0.343]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
array([[ 33.541,   1.447,   5.195, -34.401],


   [  1.447,   0.147,   0.526,  -1.484],
   [  5.195,   0.526,   0.889,  -5.328],
   [-34.401,  -1.484,  -5.328,  34.283]])

&gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
array([[ 0.335,  0.029,  0.052, -0.67 ],


   [ 0.029,  0.001,  0.005, -0.015],
   [ 0.052,  0.005,  0.008, -0.104],
   [-0.67 , -0.015, -0.104,  0.343]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ 33.539,   1.493,   5.207, -34.399],


   [  1.493,   0.065,   0.232,  -1.488],
   [  5.207,   0.232,   0.808,  -5.341],
   [-34.399,  -1.488,  -5.341,  34.283]])
</code></pre>
<p>Katzova ocijena neusmjerenog grafa s težinama.</p>
<pre><code>&gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
&gt;&gt;&gt; gamma.round(3)
array([-0.336,  1.022])
&gt;&gt;&gt; W.round(3)
array([[-0.699,  0.699],


   [ 0.031,  0.031],
   [-0.108,  0.108],
   [-0.706, -0.706]])
</code></pre>
<p>Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>score_k == W_k @ np.diag(gamma_k) @ W_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def t_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated Katz score* kvadratne simetrične matrice bliskosti.

    *Truncated Katz score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, M) symmetric array
        Matrica bliskosti neusmjerenog težinskog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, M], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    gamma_k : (k,) array
        Za konačni niz `l` svojstvenih vrijednosti matrice `X` poredan silazno
        po apsolutnoj vrijednosti, `gamma_k[i]` iznosi
        `(1.0 - beta * l[i]) ** -1 - 1.0`.  Ova se povratna vrijednost vraća ako
        je `compute` laž.

    W_k : (M, k) array
        Matrica normiranih stupaca.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije kvadratna simetrična matrica,
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `beta` nije u
        intervalu (0, 1), parametar `k` nije u intervalu [1, M], parametar
        `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `np.linalg.eig(...)` ne hvataju se.

    Vidi također
    ------------
    bt_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 0, 1],
    ...      [0, 0, 1, 0],
    ...      [0, 0, 0, 1],
    ...      [0, 0, 0, 0]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X |= X.T
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 0, 1],
           [0, 0, 1, 0],
           [0, 1, 0, 1],
           [1, 0, 1, 0]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[0.6, 0.4, 0.8, 1.2],
           [0.4, 0.6, 1.2, 0.8],
           [0.8, 1.2, 1.4, 1.6],
           [1.2, 0.8, 1.6, 1.4]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[-0.05 , -0.978, -1.003, -0.051],
           [-0.978, -0.05 , -0.051, -1.003],
           [-1.003, -0.051, -1.052, -1.028],
           [-0.051, -1.003, -1.028, -1.052]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[0.524, 0.647, 0.847, 1.047],
           [0.647, 0.524, 1.047, 0.847],
           [0.847, 1.047, 1.371, 1.694],
           [1.047, 0.847, 1.694, 1.371]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[-0.462, -0.293, -0.748, -0.474],
           [-0.293, -0.462, -0.474, -0.748],
           [-0.748, -0.474, -1.21 , -0.767],
           [-0.474, -0.748, -0.767, -1.21 ]])

    Katzova ocijena neusmjerenog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X += X.T
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X.round(3)
    array([[-0.   ,  0.   , -0.   , -1.   ],
           [ 0.   ,  0.   ,  0.286,  0.   ],
           [-0.   ,  0.286, -0.   , -0.143],
           [-1.   ,  0.   , -0.143,  0.   ]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[ 0.336,  0.007,  0.049, -0.671],
           [ 0.007,  0.021,  0.147, -0.014],
           [ 0.049,  0.147,  0.028, -0.098],
           [-0.671, -0.014, -0.098,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 33.541,   1.447,   5.195, -34.401],
           [  1.447,   0.147,   0.526,  -1.484],
           [  5.195,   0.526,   0.889,  -5.328],
           [-34.401,  -1.484,  -5.328,  34.283]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[ 0.335,  0.029,  0.052, -0.67 ],
           [ 0.029,  0.001,  0.005, -0.015],
           [ 0.052,  0.005,  0.008, -0.104],
           [-0.67 , -0.015, -0.104,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 33.539,   1.493,   5.207, -34.399],
           [  1.493,   0.065,   0.232,  -1.488],
           [  5.207,   0.232,   0.808,  -5.341],
           [-34.399,  -1.488,  -5.341,  34.283]])

    Katzova ocijena neusmjerenog grafa s težinama.

    &gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; gamma.round(3)
    array([-0.336,  1.022])
    &gt;&gt;&gt; W.round(3)
    array([[-0.699,  0.699],
           [ 0.031,  0.031],
           [-0.108,  0.108],
           [-0.706, -0.706]])

    Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == W_k @ np.diag(gamma_k) @ W_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if X.shape[0] != X.shape[1]:
        raise ValueError(&#39;X mora biti kvadratna matrica.&#39;)
    if not _np.array_equal(X, X.T):
        raise ValueError(&#39;X mora biti simetricna matrica.&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1).&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti dimenzije matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    l, W = _np.linalg.eig(X)
    I = _np.flip(_np.argsort(_np.abs(l))).copy(order = &#39;F&#39;)
    l = _np.array(l[I], copy = True, order = &#39;F&#39;)
    W = _np.array(W[:, I], copy = True, order = &#39;F&#39;)
    del I
    if k is None:
        k = (
            1 if _np.isclose(1.0, 1.0 + l[0])
                else int((~_np.isclose(1.0, 1.0 + l / l[0])).sum())
        )
    l = l[:k].copy(order = &#39;F&#39;)
    W = W[:, :k].copy(order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        ((1.0 - beta * l) ** -1 - 1.0).copy(order = &#39;F&#39;) * W,
        W.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else ((1.0 - beta * l) ** -1 - 1.0, W)</code></pre>
</details>
</dd>
<dt id="tlp.tsvd"><code class="name flex">
<span>def <span class="ident">tsvd</span></span>(<span>X, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated singular value decomposition</em> (<em>TSVD</em>) matrice bliskosti.</p>
<p><em>TSVD</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Matrica numeričkih definiranih i konačnih vrijednosti.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>M</code>, <code>N</code>)], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija matrice <code>X</code> na prvih
<code>k</code> singularnih vrijednosti; inače je povratna vrijednost rekompozicija
(zadana vrijednost je laž).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>X_k</code></strong> :&ensp;(<code>M</code>, <code>M</code>) <code>array</code></dt>
<dd>Rekompozicija iz <em>TSVD</em> matrice <code>X</code> na prvih <code>k</code> singularnih
vrijednosti.
Ova se povratna vrijednost vraća ako je <code>compute</code> istina.</dd>
<dt><strong><code>U_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
<dt><strong><code>s_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd><code>k</code> najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
se povratna vrijednost vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>V_k</code></strong> :&ensp;(<code>N</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>k</code> nije
cijeli broj, parametar <code>compute</code> nije istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije matrica, sadrži nedefinirane ili
beskonačne vrijednosti, parametar <code>k</code> nije u intervalu [1, min(M, N)],
parametar <code>compute</code> nije laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.partial_svd(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[ 1,  5,  0, -2],
...      [-2,  4,  0,  1],
...      [ 0, -1, -1,  0]]
&gt;&gt;&gt; tsvd(X).round(3)
array([[ 1.,  5., -0., -2.],


   [-2.,  4.,  0.,  1.],
   [ 0., -1., -1., -0.]])

&gt;&gt;&gt; tsvd(X, k = 1).round(3)
array([[-0.321,  5.1  ,  0.121, -0.769],


   [-0.243,  3.869,  0.092, -0.584],
   [ 0.063, -0.997, -0.024,  0.15 ]])

&gt;&gt;&gt; tsvd(X, k = 2).round(3)
array([[ 1.012,  5.   ,  0.108, -1.988],


   [-1.988,  4.   ,  0.108,  1.012],
   [ 0.108, -1.   , -0.024,  0.108]])
</code></pre>
<p>Rekompozicija matrice.</p>
<pre><code>&gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
&gt;&gt;&gt; U.round(3)
array([[-0.787, -0.607],


   [-0.597,  0.794],
   [ 0.154, -0.021]])

&gt;&gt;&gt; s.round(3)
array([6.566, 2.98 ])
&gt;&gt;&gt; V.round(3)
array([[ 0.062, -0.737],


   [-0.987,  0.055],
   [-0.023,  0.007],
   [ 0.149,  0.674]])
</code></pre>
<p>Dekompozicija matrice <code>X</code>.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>X_k == U_k @ np.diag(s_k) @ V_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tsvd (X, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated singular value decomposition* (*TSVD*) matrice bliskosti.

    *TSVD* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica numeričkih definiranih i konačnih vrijednosti.

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X na za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija matrice `X` na prvih
        `k` singularnih vrijednosti; inače je povratna vrijednost rekompozicija
        (zadana vrijednost je laž).

    Povratne vrijednosti
    --------------------
    X_k : (M, M) array
        Rekompozicija iz *TSVD* matrice `X` na prvih `k` singularnih
        vrijednosti.  Ova se povratna vrijednost vraća ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    s_k : (k,) array
        `k` najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
        se povratna vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `compute` nije istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `k` nije u intervalu [1, min(M, N)],
        parametar `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; X = [[ 1,  5,  0, -2],
    ...      [-2,  4,  0,  1],
    ...      [ 0, -1, -1,  0]]
    &gt;&gt;&gt; tsvd(X).round(3)
    array([[ 1.,  5., -0., -2.],
           [-2.,  4.,  0.,  1.],
           [ 0., -1., -1., -0.]])
    &gt;&gt;&gt; tsvd(X, k = 1).round(3)
    array([[-0.321,  5.1  ,  0.121, -0.769],
           [-0.243,  3.869,  0.092, -0.584],
           [ 0.063, -0.997, -0.024,  0.15 ]])
    &gt;&gt;&gt; tsvd(X, k = 2).round(3)
    array([[ 1.012,  5.   ,  0.108, -1.988],
           [-1.988,  4.   ,  0.108,  1.012],
           [ 0.108, -1.   , -0.024,  0.108]])

    Rekompozicija matrice.

    &gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[-0.787, -0.607],
           [-0.597,  0.794],
           [ 0.154, -0.021]])
    &gt;&gt;&gt; s.round(3)
    array([6.566, 2.98 ])
    &gt;&gt;&gt; V.round(3)
    array([[ 0.062, -0.737],
           [-0.987,  0.055],
           [-0.023,  0.007],
           [ 0.149,  0.674]])

    Dekompozicija matrice `X`.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `X_k == U_k @ np.diag(s_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; max(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj TSVD.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(max(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati dekompoziciju ili rekompoziciju ovisno o vrijednosti parametra
    # compute.
    return (
        _np.matmul(s * U, V.T.copy(order = &#39;F&#39;)).copy(order = &#39;F&#39;) if compute
            else (U, s, V)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#zavisnosti">Zavisnosti</a></li>
<li><a href="#napomene">Napomene</a></li>
<li><a href="#literatura">Literatura</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tlp.bt_Katz_score" href="#tlp.bt_Katz_score">bt_Katz_score</a></code></li>
<li><code><a title="tlp.cp_score" href="#tlp.cp_score">cp_score</a></code></li>
<li><code><a title="tlp.cwt" href="#tlp.cwt">cwt</a></code></li>
<li><code><a title="tlp.t_Katz_score" href="#tlp.t_Katz_score">t_Katz_score</a></code></li>
<li><code><a title="tlp.tsvd" href="#tlp.tsvd">tsvd</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>