<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>tlp API documentation</title>
<meta name="description" content="Funkcije za predviđanje veza u mreži kroz vrijeme …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tlp</code></h1>
</header>
<section id="section-intro">
<p>Funkcije za predviđanje veza u mreži kroz vrijeme.</p>
<h2 id="zavisnosti">Zavisnosti</h2>
<p>Kod je izvršiv samo u <strong><em>Python</em> 3</strong> okruženju zbog svojih zavisnosti.</p>
<ol>
<li>standardna <em>Python</em> biblioteka:<ol>
<li><a href="http://docs.python.org/3/library/copy.html">copy</a>,</li>
<li><a href="http://docs.python.org/3/library/functools.html">functools</a>,</li>
<li><a href="http://docs.python.org/3/library/math.html">math</a>,</li>
<li><a href="http://docs.python.org/3/library/numbers.html">numbers</a>,</li>
</ol>
</li>
<li>ostali paketi:<ol>
<li><a href="http://numpy.org/">NumPy</a> &ndash; tenzori su reprezentirani kao objekti
klase <code>numpy.ndarray</code>.</li>
<li><a href="http://tensorly.org/">TensorLy</a> &ndash; dekompozicija tenzora
realizirana je metodama iz biblioteke paketa <em>TensorLy</em> (taj je paket
podržan samo za <em>Python</em> 3 okruženje).</li>
</ol>
</li>
</ol>
<h2 id="napomene">Napomene</h2>
<p>U ostatku dokumentacije pretpostavlja se da su izvršene linije</p>
<pre><code class="Python">import numpy as np
import tensorLy as tl

from tlp import *
</code></pre>
<h2 id="literatura">Literatura</h2>
<ol>
<li><a class="anchor" id="bib-dunlavy-10"></a> D. M. Dunlavy, T. G. Kolda,
E. Acar, <em>Temporal Link Prediction using Matrix and Tensor Factorizations</em>,
2010, arXiv: <a href="http://arxiv.org/abs/1005.4006">1005.4006 [math.NA]</a>.</li>
<li><a class="anchor" id="bib-trubetskoy-16"></a> G. Trubetskoy,
Holt-Winters Forecasting for Dummies - Part III, dostupno na
<a href="http://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/&gt;">&lt;http://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/</a>,
(lipanj 2019.).</li>
</ol>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Funkcije za predviđanje veza u mreži kroz vrijeme.

##  Zavisnosti

Kod je izvršiv samo u ***Python* 3** okruženju zbog svojih zavisnosti.

1.  standardna *Python* biblioteka:
    1.  [copy](http://docs.python.org/3/library/copy.html),
    2.  [functools](http://docs.python.org/3/library/functools.html),
    3.  [math](http://docs.python.org/3/library/math.html),
    4.  [numbers](http://docs.python.org/3/library/numbers.html),
2.  ostali paketi:
    1.  [NumPy](http://numpy.org/) &amp;ndash; tenzori su reprezentirani kao objekti
        klase `numpy.ndarray`.
    2.  [TensorLy](http://tensorly.org/) &amp;ndash; dekompozicija tenzora
        realizirana je metodama iz biblioteke paketa *TensorLy* (taj je paket
        podržan samo za *Python* 3 okruženje).

##  Napomene

U ostatku dokumentacije pretpostavlja se da su izvršene linije

```Python
import numpy as np
import tensorLy as tl

from tlp import *
```

##  Literatura

1.  &lt;a class=\&#34;anchor\&#34; id=\&#34;bib-dunlavy-10\&#34;&gt;&lt;/a&gt; D. M. Dunlavy, T. G. Kolda,
    E. Acar, *Temporal Link Prediction using Matrix and Tensor Factorizations*,
    2010, arXiv: [1005.4006 [math.NA]](http://arxiv.org/abs/1005.4006).
2.  &lt;a class=\&#34;anchor\&#34; id=\&#34;bib-trubetskoy-16\&#34;&gt;&lt;/a&gt; G. Trubetskoy,
    Holt-Winters Forecasting for Dummies - Part III, dostupno na
    [http://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/](http://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/),
    (lipanj 2019.).

&#34;&#34;&#34;

# Standardna Python biblioteka.
import copy as _copy
import functools as _functools
import math as _math
import numbers as _numbers

# SciPy paketi.
import numpy as _np

# TensorLy paket.
import tensorly as _tl
from tensorly.decomposition import parafac as _parafac

# Osiguraj da se koristi numpy backend u TensorLy-ju.
if _tl.get_backend() != &#39;numpy&#39;:
    _tl.set_backend(&#39;numpy&#39;)

class ExponentialSmooth (object):
    &#34;&#34;&#34;
    Prognoza numeričkih podataka trostrukim eksponencijalnim izglađivanjem.

    Prognoza se računa formulama opisanim u [[2](#bib-trubetskoy-16)].

    &#34;&#34;&#34;

    def __new__ (cls):
        # Saniraj parametar cls.
        if not issubclass(cls, ExponentialSmooth):
            raise TypeError(&#39;cls mora biti ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = super(ExponentialSmooth, cls).__new__(cls)

        # Vrati novi objekt.
        return instance

    def __init__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Inicijaliziraj self.
        super(ExponentialSmooth, self).__init__()

        # Inicijaliziraj atribute objekta self.
        self._a = _np.zeros(tuple([0]), dtype = float, order = &#39;F&#39;)
        self._n = 0
        self._b = 0.0
        self._s = _np.zeros(tuple([0]), dtype = float, order = &#39;F&#39;)

    def __copy__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = ExponentialSmooth()

        # Postavi atribute novog objekta na atribute objekta self.
        instance._a = self._a
        instance._n = self._n
        instance._b = self._b
        instance._s = self._s

        # Vrati novi objekt.
        return instance

    def __deepcopy__ (self, memo = dict()):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = ExponentialSmooth()

        # Kopiraj atribute objekta self u atribute novog objekta.
        instance._a = _copy.deepcopy(self._a, memo)
        instance._n = _copy.deepcopy(self._n, memo)
        instance._b = _copy.deepcopy(self._b, memo)
        instance._s = _copy.deepcopy(self._s, memo)

        # Vrati novi objekt.
        return instance

    def __repr__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati tekstualnu reprezentaciju objekta self.
        return &#39;&lt;{class_name:s}: ({series_shape:s}; {season_length:d})&gt;&#39;.format(
            class_name = self.__class__.__name__,
            series_shape = repr(tuple(self._a.shape)),
            season_length = self._n
        )

    def fit (self, a, n):
        &#34;&#34;&#34;
        Pripremi prognoziranje vrijednosti tenzora `a` s periodom duljine `n`.

        Parametri
        ---------
        a : array
            Tenzor čije prognoze će se računati (po zadnjoj dimenziji).

        n : int in range [1, a.shape[-1] // 2]
            Duljina perioda u tenzoru `a`.

        Povratne vrijednosti
        --------------------
        self : ExponentialSmooth
            Povratna vrijednost je `self`.

        Iznimke
        -------
        TypeError
            Parametar `a` nije nije tenzor numeričkih vrijednosti, parametar `n`
            nije vijeli broj.

        ValueError
            Parametar `a` je prazni tenzor, sadrži nedefinrane ili beskonačne
            vrijednosti, parametar `n` nije u intervalu [1, `a.shape[-1] // 2`].

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Saniraj parametar a.
        if not isinstance(a, _np.ndarray):
            if not (hasattr(a, &#39;__iter__&#39;) or hasattr(a, &#39;__array__&#39;)):
                raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
            try:
                a = _np.array(a)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
        if not issubclass(
            a.dtype.type,
            (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
        ):
            raise TypeError(&#39;a mora biti tenzor numerickih vrijednosti.&#39;)
        if not a.ndim:
            raise ValueError(&#39;a mora biti barem jednodimenzionalni tenzor.&#39;)
        if not a.size:
            raise ValueError(&#39;a mora biti neprazni tenzor.&#39;)
        if (_np.isnan(a) | _np.isinf(a)).any():
            raise ValueError(
                &#39;a mora sadrzavati samo definirane i konacne vrijednosti.&#39;
            )
        if isinstance(a, _np.matrix):
            a = a.A

        # Saniraj parametar n.
        if not isinstance(n, _numbers.Integral):
            raise TypeError(&#39;n mora biti klase int.&#39;)
        try:
            n = _copy.deepcopy(int(n))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;n mora biti klase int.&#39;)
        if n &lt;= 0:
            raise ValueError(&#39;n mora biti strogo pozitivan.&#39;)
        if n &gt; a.shape[-1] // 2:
            raise ValueError(&#39;n ne smije biti veci od a.shape[-1] // 2.&#39;)

        # Spremi kopije parametara u atribute objekta self.  Jednostavnosti
        # računa radi, posljednja dimenzija tenzora a prebacuje se na prvo
        # mjesto.
        self._a = _np.moveaxis(a, -1, 0).copy(order = &#39;F&#39;)
        self._n = _copy.deepcopy(n)

        # Izračunaj pomoćne varijable broj cijelih perioda u tenzoru a i srednje
        # vrijednosti perioda.
        N = int(_math.floor(float(self._a.shape[0]) / self._n))
        avg = _np.array(
            [
                self._a[
                    i * self._n:_np.minimum((i + 1) * self._n, self._a.shape[0])
                ].mean(axis = 0) for i in iter(range(N))
            ],
            order = &#39;F&#39;
        )

        # Izračunaj (i spremi u atribute objekta self) inicijalni trend i
        # inicijalne sezonalne komponente tenzora a.
        self._b = (
            (self._a[self._n:2 * self._n] - self._a[:self._n]).sum() /
            float(self._n) ** 2
        )
        if isinstance(self._b, _np.ndarray):
            if self._b.shape == tuple():
                self._b = self._b.dtype.type(self._b)
        self._s = _np.array(
            [
                (self._a[i:N * self._n:self._n] - avg).sum(axis = 0)
                    for i in iter(range(self._n))
            ],
            order = &#39;F&#39;
        ) / float(N)

        # Vrati self.
        return self

    def predict (self, k = 1, theta = 0.5):
        &#34;&#34;&#34;
        Predvidi vrijednosti tenzora.

        Parametri
        ---------
        k : int in range [1, +inf), optional
            Broj vrijednosti koje se predviđa (zadana vrijednost je 1).

        theta : float in range [0, 1] or tuple of 3 floats in range [0, 1]
            Parametri eksponencijalnog izglađivanja (zadana vrijednost je 0.5).
            Ako je jedinstvena vrijednost, uzima se
            `theta = (theta, theta, theta)`.  Vrijednost `theta[0]` koeficijent
            je izglađivanja visine, vrijednost `theta[1]` koeficijent je
            izglađivanja trenda, a vrijednost `theta[2]` je koeficijent
            izglađivanja sezonalnih komponenti.

        Povratne vrijednosti
        --------------------
        y : array
            Predviđenih `k` vrijednosti tenzora `a`.  Prvih `a.ndim - 1`
            dimenzija jednakih je veličina kao tenzora `a`, a posljednja
            dimenzija je veličine `k`.  Ako je `k == 1`, onda je povratna
            vrijednost dimenzionalnosti `a.ndim - 1`.  Ako je `a`
            jednodimenzionalni tenzor i `k == 1`, onda je povratna vrijednost
            skalar.

        Iznimke
        -------
        TypeError
            Parametar `k` nije realni broj, parametar `theta` sadrži vrijednost
            koja nije realni broj.

        ValueError
            Parametar `k` nije u intervalu [1, +inf), parametar `theta` sadrži
            vrijednost koja nije u intervalu [0, 1].

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Saniraj parametar k.
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;k mora biti klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)

        # Saniraj parametar theta.
        if not isinstance(theta, tuple):
            theta = _copy.deepcopy((theta, theta, theta))
        if len(theta) != 3:
            raise ValueError(&#39;theta mora biti troclani tuple.&#39;)
        theta = list(theta)
        for i in iter(range(3)):
            if not (isinstance(theta[i], _numbers.Real)):
                raise TypeError(&#39;theta mora biti klase float.&#39;)
            try:
                theta[i] = _copy.deepcopy(float(theta[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;theta mora biti klase float.&#39;)
            if _math.isnan(theta[i]) or _math.isinf(theta[i]):
                raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
            if theta[i] &lt; 0.0 or theta[i] &gt; 1.0:
                raise ValueError(&#39;theta mora biti u intervalu [0, 1].&#39;)
        theta = tuple(theta)

        # Izračunaj 1 - theta po komponentama.
        one_min_theta = (1.0 - theta[0], 1.0 - theta[1], 1.0 - theta[2])

        # Eksponencijalnim izglađivanjem izračunaj tenzor y duljine
        # a.shape[-1] + k.
        y = None
        if self._a.ndim == 1:
            y = _np.zeros(self._a.size + k, dtype = self._s.dtype, order = &#39;F&#39;)
        else:
            y = _np.zeros(
                tuple(
                    _np.concatenate(
                        ([self._a.shape[0] + k], self._a.shape[1:])
                    ).tolist()
                ),
                dtype = self._s.dtype,
                order = &#39;F&#39;
        )
        b = _copy.deepcopy(self._b)
        s = _copy.deepcopy(self._s)
        l = (_copy.deepcopy(self._a[0]), _copy.deepcopy(self._a[0]))
        for i in iter(range(1, int(self._a.shape[0]))):
            val = _copy.deepcopy(self._a[i])
            l = (
                l[1],
                (
                    theta[0] * (val - s[i % self._n]) +
                    one_min_theta[0] * (l[1] + b)
                )
            )
            b = theta[1] * (l[1] - l[0]) + one_min_theta[1] * b
            s[i % self._n] = (
                theta[2] * (val - l[1]) + one_min_theta[2] * s[i % self._n]
            )
            y[i] = l[1] + b + s[i % self._n]
        for i in iter(range(int(self._a.shape[0]), int(y.shape[0]))):
            y[i] = (l[1] + (i - self._a.shape[0] + 1) * b) + s[i % self._n]

        # Spremi samo posljednjih k vrijednosti u tenzoru y.
        y = y[int(self._a.shape[0]):].copy(order = &#39;F&#39;)

        # Po potrebi pojednostavi dimenzionalnost tenzora y odnosno pretvori ga
        # u skalar.
        if isinstance(y, _np.ndarray):
            if k == 1:
                if y.ndim == 1:
                    y = y.dtype.type(y)
                else:
                    y.shape = y.shape[1:]
            else:
                y = _np.moveaxis(y, 0, -1).copy(order = &#39;F&#39;)

        # Vrati izračunati tenzor y.
        return y

    @property
    def series_ (self):
        &#34;&#34;&#34;
        Tenzor čije prognoze se računaju eksponencijalnim izglađivanjem.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati tenzor.
        return _np.moveaxis(self._a, 0, -1).copy(order = &#39;F&#39;)

    @property
    def season_length_ (self):
        &#34;&#34;&#34;
        Duljina perioda vrijednosti tenzora.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati duljinu perioda tenzora.
        return _copy.deepcopy(self._n)

    @property
    def initial_trend_ (self):
        &#34;&#34;&#34;
        Inicijalni trend tenzora.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati inicijalni trend tenzora.
        return _copy.deepcopy(self._b)

    @property
    def initial_seasonal_components_ (self):
        &#34;&#34;&#34;
        Inicijalne sezonalne komponente tenzora.

        &#34;&#34;&#34;

        # saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati inicijalne sezonalne komponente tenzora.
        return _copy.deepcopy(self._s)

def cwt (Z, theta = 0.5, norm = False):
    &#34;&#34;&#34;
    Izračunaj *collapsed weighted tensor* (*CWT*).

    *CWT* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CWT* računa.

    theta : float in range [0 to 1), optional
        Parametar *gubitka* relevantnosti stanja kroz vrijeme (zadana vrijednost
        je 0.5).

    norm : boolean, optional
        Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
        to jest, povratna vrijednost je podijeljena sa
        `sum((1 - theta) ** i for i in range(Z.shape[-1]))` (zadana vrijednost
        je laž).

    Povratne vrijednosti
    --------------------
    Z_cwt : array
        *CWT* zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je za 1
        manje od tenzora `Z`, a oblikom je jednak obliku `Z.shape[:-1]`.  Ako je
        `Z` jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `theta` nije
        realni broj.

    ValueError
        Parametar `Z` je skalar ili prazni tenzor, parametar `theta` nije u
        intervalu [0, 1).

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cwt(Z)
    array([[ 2.5,  5.5,  8.5, 11.5],
           [14.5, 17.5, 20.5, 23.5],
           [26.5, 29.5, 32.5, 35.5]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0)
    array([[ 3.,  7., 11., 15.],
           [19., 23., 27., 31.],
           [35., 39., 43., 47.]])
    &gt;&gt;&gt; cwt(Z, norm = True).round(3)
    array([[ 1.667,  3.667,  5.667,  7.667],
           [ 9.667, 11.667, 13.667, 15.667],
           [17.667, 19.667, 21.667, 23.667]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
    array([[ 1.5,  3.5,  5.5,  7.5],
           [ 9.5, 11.5, 13.5, 15.5],
           [17.5, 19.5, 21.5, 23.5]])

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar theta.
    if not isinstance(theta, _numbers.Real):
        raise TypeError(&#39;theta mora biti realni broj.&#39;)
    try:
        theta = _copy.deepcopy(float(theta))
    except (TypeError, ValueError):
        raise TypeError(&#39;theta mora biti klase float.&#39;)
    if _math.isnan(theta) or _math.isinf(theta):
        raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
    if not (theta &gt;= 0.0 and theta &lt; 1.0):
        raise ValueError(&#39;theta mora biti u intervalu [0, 1).&#39;)

    # Saniraj parametar norm.
    if not isinstance(
        norm,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)
    if norm not in {0, False, 1, True}:
        raise ValueError(&#39;norm mora biti laz/istina.&#39;)
    try:
        norm = _copy.deepcopy(bool(norm))
    except (TypeError, ValueError):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)

    # Izračunaj prvih Z.shape[-1] elemenata geometrijskog niza s koeficijentom
    # 1 - theta.
    one_min_theta = _np.flip(
        (1.0 - theta) ** _np.arange(Z.shape[-1], dtype = int)
    ).copy(order = &#39;F&#39;)

    # Izračunaj kompresijsku sumu.
    Z_compressed = (one_min_theta * Z).sum(axis = -1).copy(order = &#39;F&#39;)

    # Ako je norm istina, podijeli kompresijsku sumu sa _theta.sum().
    if norm:
        Z_compressed /= one_min_theta.sum()

    # Po potrebi pretvori Z u skalar.
    if isinstance(Z_compressed, _np.ndarray):
        if Z_compressed.shape == tuple():
            Z_compressed = Z_compressed.dtype.type(Z_compressed)

    # Vrati kompresijsku sumu.
    return Z_compressed

def tsvd (X, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated singular value decomposition* (*TSVD*) matrice bliskosti.

    *TSVD* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica numeričkih definiranih i konačnih vrijednosti.

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija matrice `X` na prvih
        `k` singularnih vrijednosti; inače je povratna vrijednost rekompozicija
        (zadana vrijednost je laž).

    Povratne vrijednosti
    --------------------
    X_k : (M, M) array
        Rekompozicija iz *TSVD* matrice `X` na prvih `k` singularnih
        vrijednosti.  Ova se povratna vrijednost vraća ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    s_k : (k,) array
        `k` najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
        se povratna vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `compute` nije istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `k` nije u intervalu [1, min(M, N)],
        parametar `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; X = [[ 1,  5,  0, -2],
    ...      [-2,  4,  0,  1],
    ...      [ 0, -1, -1,  0]]
    &gt;&gt;&gt; tsvd(X).round(3)
    array([[ 1.,  5., -0., -2.],
           [-2.,  4.,  0.,  1.],
           [ 0., -1., -1., -0.]])
    &gt;&gt;&gt; tsvd(X, k = 1).round(3)
    array([[-0.321,  5.1  ,  0.121, -0.769],
           [-0.243,  3.869,  0.092, -0.584],
           [ 0.063, -0.997, -0.024,  0.15 ]])
    &gt;&gt;&gt; tsvd(X, k = 2).round(3)
    array([[ 1.012,  5.   ,  0.108, -1.988],
           [-1.988,  4.   ,  0.108,  1.012],
           [ 0.108, -1.   , -0.024,  0.108]])

    Rekompozicija matrice.

    &gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[-0.787, -0.607],
           [-0.597,  0.794],
           [ 0.154, -0.021]])
    &gt;&gt;&gt; s.round(3)
    array([6.566, 2.98 ])
    &gt;&gt;&gt; V.round(3)
    array([[ 0.062, -0.737],
           [-0.987,  0.055],
           [-0.023,  0.007],
           [ 0.149,  0.674]])

    Dekompozicija matrice `X`.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `X_k == U_k @ np.diag(s_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; max(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj TSVD.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(max(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati dekompoziciju ili rekompoziciju ovisno o vrijednosti parametra
    # compute.
    return (
        _np.matmul(s * U, V.T.copy(order = &#39;F&#39;)).copy(order = &#39;F&#39;) if compute
            else (U, s, V)
    )

def t_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated Katz score* kvadratne simetrične matrice bliskosti.

    *Truncated Katz score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, M) symmetric array
        Matrica bliskosti neusmjerenog težinskog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, M], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    gamma_k : (k,) array
        Za konačni niz `l` svojstvenih vrijednosti matrice `X` poredan silazno
        po apsolutnoj vrijednosti, `gamma_k[i]` iznosi
        `(1 - beta * l[i]) ** -1 - 1`.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    W_k : (M, k) array
        Matrica normiranih stupaca.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije kvadratna simetrična matrica,
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `beta` nije u
        intervalu (0, 1), parametar `k` nije u intervalu [1, `M`], parametar
        `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `np.linalg.eig(...)` ne hvataju se.

    Vidi također
    ------------
    bt_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 0, 1],
    ...      [0, 0, 1, 0],
    ...      [0, 0, 0, 1],
    ...      [0, 0, 0, 0]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X |= X.T
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 0, 1],
           [0, 0, 1, 0],
           [0, 1, 0, 1],
           [1, 0, 1, 0]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[0.6, 0.4, 0.8, 1.2],
           [0.4, 0.6, 1.2, 0.8],
           [0.8, 1.2, 1.4, 1.6],
           [1.2, 0.8, 1.6, 1.4]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[-0.05 , -0.978, -1.003, -0.051],
           [-0.978, -0.05 , -0.051, -1.003],
           [-1.003, -0.051, -1.052, -1.028],
           [-0.051, -1.003, -1.028, -1.052]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[0.524, 0.647, 0.847, 1.047],
           [0.647, 0.524, 1.047, 0.847],
           [0.847, 1.047, 1.371, 1.694],
           [1.047, 0.847, 1.694, 1.371]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[-0.462, -0.293, -0.748, -0.474],
           [-0.293, -0.462, -0.474, -0.748],
           [-0.748, -0.474, -1.21 , -0.767],
           [-0.474, -0.748, -0.767, -1.21 ]])

    Katzova ocijena neusmjerenog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X += X.T
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X.round(3)
    array([[-0.   ,  0.   , -0.   , -1.   ],
           [ 0.   ,  0.   ,  0.286,  0.   ],
           [-0.   ,  0.286, -0.   , -0.143],
           [-1.   ,  0.   , -0.143,  0.   ]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[ 0.336,  0.007,  0.049, -0.671],
           [ 0.007,  0.021,  0.147, -0.014],
           [ 0.049,  0.147,  0.028, -0.098],
           [-0.671, -0.014, -0.098,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 33.541,   1.447,   5.195, -34.401],
           [  1.447,   0.147,   0.526,  -1.484],
           [  5.195,   0.526,   0.889,  -5.328],
           [-34.401,  -1.484,  -5.328,  34.283]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[ 0.335,  0.029,  0.052, -0.67 ],
           [ 0.029,  0.001,  0.005, -0.015],
           [ 0.052,  0.005,  0.008, -0.104],
           [-0.67 , -0.015, -0.104,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 33.539,   1.493,   5.207, -34.399],
           [  1.493,   0.065,   0.232,  -1.488],
           [  5.207,   0.232,   0.808,  -5.341],
           [-34.399,  -1.488,  -5.341,  34.283]])

    Katzova ocijena neusmjerenog grafa s težinama.

    &gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; gamma.round(3)
    array([-0.336,  1.022])
    &gt;&gt;&gt; W.round(3)
    array([[-0.699,  0.699],
           [ 0.031,  0.031],
           [-0.108,  0.108],
           [-0.706, -0.706]])

    Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == W_k @ np.diag(gamma_k) @ W_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if X.shape[0] != X.shape[1]:
        raise ValueError(&#39;X mora biti kvadratna matrica.&#39;)
    if not _np.array_equal(X, X.T):
        raise ValueError(&#39;X mora biti simetricna matrica.&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1).&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti dimenzije matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    l, W = _np.linalg.eig(X)
    I = _np.flip(_np.argsort(_np.abs(l))).copy(order = &#39;F&#39;)
    l = _np.array(l[I], copy = True, order = &#39;F&#39;)
    W = _np.array(W[:, I], copy = True, order = &#39;F&#39;)
    del I
    if k is None:
        k = (
            1 if _np.isclose(1.0, 1.0 + l[0])
                else int((~_np.isclose(1.0, 1.0 + l / l[0])).sum())
        )
    l = l[:k].copy(order = &#39;F&#39;)
    W = W[:, :k].copy(order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        ((1.0 - beta * l) ** -1 - 1.0).copy(order = &#39;F&#39;) * W,
        W.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else ((1.0 - beta * l) ** -1 - 1.0, W)

def bt_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated bipartite Katz score* matrice bliskosti.

    *Bipartite truncated Katz score* se računa po formuli iz
    [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica bliskosti težinskog bipartitnog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.  Budući da su po pretpostavci
        kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
        osobe, a stupci konferencije), simetričnost matrice `X` ne znači
        simetričnost grafa.  Za Katzovu ocijenu neusmjerenog grafa koristi
        se `t_Katz_score`.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    psi_m_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_m_k[i]` iznosi
        `beta * s[i] * (1 - beta ** 2 * s[i] ** 2) ** -1`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    psi_p_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_p_k[i]` iznosi
        `(1 - beta ** 2 * s[i] ** 2) ** -1 - 1`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `beta` nije u intervalu (0, 1),
        parametar `k` nije u intervalu [1, `M`], parametar `compute` nije
        laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Vidi također
    ------------
    t_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 1, 1],
    ...      [1, 0, 0, 1],
    ...      [0, 1, 1, 1]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 1, 1],
           [1, 0, 0, 1],
           [0, 1, 1, 1]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.545, -0.909, -1.091, -1.636],
           [ 0.364, -0.727, -1.273, -0.909],
           [-0.727, -0.545, -1.455, -2.182]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 0.057, -0.98 , -0.054,  0.003],
           [-2.356,  1.151,  1.208, -1.148],
           [ 1.151, -0.111, -1.091,  0.06 ]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.476, -0.653, -1.201, -1.677],
           [ 0.351, -0.776, -1.252, -0.901],
           [-0.776, -0.724, -1.378, -2.153]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 0.255, -0.246, -0.369, -0.114],
           [-2.393,  1.012,  1.267, -1.126],
           [ 1.012, -0.625, -0.87 ,  0.142]])

    Katzova ocijena bipartitnog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X
    array([[-0.   ,  0.   , -0.25 ,  0.125],
           [-1.   ,  0.   , -0.   ,  0.125],
           [-0.   ,  0.5  , -0.25 ,  0.125]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.003,  0.005, -0.13 ,  0.065],
           [-0.67 ,  0.001, -0.001,  0.084],
           [-0.003,  0.272, -0.139,  0.07 ]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ -0.516,   0.063,  -0.3  ,   0.214],
           [-28.756,   0.338,  -0.298,   3.744],
           [ -0.676,   0.723,  -0.393,   0.281]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.008,  0.072, -0.047,  0.024],
           [-0.67 ,  0.001, -0.002,  0.085],
           [-0.001,  0.253, -0.163,  0.082]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ -0.527,   0.199,  -0.13 ,   0.131],
           [-28.756,   0.337,  -0.3  ,   3.745],
           [ -0.673,   0.684,  -0.442,   0.305]])

    Katzova ocijena bipartitnog grafa s težinama.

    &gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[ 0.019, -0.275],
           [ 1.   ,  0.029],
           [ 0.025, -0.961]])
    &gt;&gt;&gt; psi_m.round(3)
    array([0.676, 0.324])
    &gt;&gt;&gt; psi_p.round(3)
    array([0.341, 0.096])
    &gt;&gt;&gt; V.round(3)
    array([[-0.991, -0.049],
           [ 0.012, -0.812],
           [-0.011,  0.522],
           [ 0.129, -0.255]])

    Dekompozicija Katzove ocijene bipartitnog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == U_k @ np.diag(psi_m_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1].&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(min(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        (beta * s * (1.0 - beta ** 2 * s ** 2) ** -1).copy(order = &#39;F&#39;) * U,
        V.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else (
        U,
        beta * s * (1.0 - beta ** 2 * s ** 2) ** -1,
        (1.0 - beta ** 2 * s ** 2) ** -1 - 1.0,
        V
    )

def cp_score (Z, k = None, T0 = None, predict = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *CP score* tenzora.

    *CP score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CP score* računa.

    k : None or int in range [1, min(Z.shape)], optional
        Rang komponenti u dekompoziciji tenzora `Z` (zadana vrijednost je
        `None`).  Ako je `None`, uzima se `k = min(Z.shape)`.

    T0 : None or int in range [1, +inf), optional
        Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
        stanja (zadana vrijednost je `None`).  Ako je `None`, uzima se
        `T0 = Z.shape[-1]`.

    predict : None or callable, optional
        Funkcija za predviđanje sljedećih stanja (zadana vrijednost je `None`).
        Ako nije `None`, funkcija prima komponentu kao objekt klase
        `numpy.ndarray` oblika `(T0, k)` osim ako je `k == 1` (u tom slučaju je
        argument `numpy.ndarray` oblika `(T0,)` za `T0 != 1` odnosno jedinstveni
        skalar za `T0 == 1`), a povratna vrijednost mora biti također
        `numpy.array` oblika `(k,)` ili `(n, k)` za neki `n &gt; 0` (predviđa se
        `n` sljedećih stanja); ako je `k == 1`, povratna vrijednost smije biti
        jedinstveni skalar.  Ako je `None`, uzima se aritmetička sredina po
        prvoj dimenziji.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija *CP* ocijene matrice
        tenzora `Z`; inače je povratna vrijednost *CP* ocijena tenzora `Z`
        (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Z_score : array
        *CP* ocijena zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je
        za 1 manje od tenzora `Z` ako `predict` predviđa točno jedno stanje, a
        inače je dimenzionalnosti iste kao `Z`.  Prvih `Z.ndim - 1` dimenzija
        jednakih je kao tenzora `Z`, a, ako `predict` predviđa `n &gt; 1` stanja,
        posljednja dimenzija je veličine `n`.  Ako je predikcija array oblika
        `()` ili `(1,)`, povratna vrijednost je skalar.  Ova se povratna
        vrijednost vraća ako je `compute` istina.

    l : (Z.ndim,) array
        Dekomponiramo li tenzor `Z` na tenzore `cp_components` ranga `k` tako da
        je `j`-ti stupac svake komponente normiran, onda je
        `Z = sum(l[i] * prod(cp_components[:, i]))`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    cpd : tuple of arrays
        `cpd` je `tuple` duljine `Z.ndim - 1`, a `cpd[i]` je, kao
        `numpy.ndarray` oblika `(Z.shape[i], k)`, `i`-ta komponenta u *CP*
        dekompoziciji tenzora `Z` na komponente ranga `k`; dodatno, norma svakog
        stupca matrice `cpd[i]` iznosi `1`.  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    p : array
        Rezultat predikcije funkcijom `predict`.  Ako je predikcija rezultirala
        jednodimenzionalnim nizom ili skalarom, `p` će ipak biti
        dvodimenzionalan (druga dimenzija je veličine 1, za skalarnu predikciju
        će i prva dimenzija biti veličine 1).  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `T0` nije cijeli broj, parametar `predict` nema
        metodu `__call__`, parametar `compute` nije istinitosna vrijednost,
        predikcija nije tenzor numeričkih vrijednosti.

    ValueError
        Parametar `Z` je prazni tenzor ili sadrži nedefinirane ili beskonačne
        vrijednosti, parametar `k` nije u intervalu [1, `min(Z.shape)`],
        parametar `T0` nije strogo pozitivan, parametar `compute` nije
        laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.

    other
        Iznimke izbačene pozivom `tl.decomposition.parafac(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cp_score(Z).round(3)
    array([[ 1.503,  3.5  ,  5.497,  7.494],
           [ 9.502, 11.5  , 13.499, 15.498],
           [17.5  , 19.5  , 21.501, 23.502]])
    &gt;&gt;&gt; cp_score(Z, k = 1).round(3)
    array([[ 3.836,  4.433,  5.031,  5.628],
           [10.188, 11.775, 13.362, 14.949],
           [16.54 , 19.116, 21.693, 24.269]])
    &gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
    array([[ 2.061,  4.009,  5.957,  7.905],
           [ 9.982, 11.99 , 13.998, 16.005],
           [17.904, 19.971, 22.038, 24.105]])
    &gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
    array([[ 3.955,  4.571,  5.187,  5.803],
           [10.504, 12.14 , 13.776, 15.412],
           [17.053, 19.709, 22.365, 25.021]])

    *CP* ocijena tenzora.

    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
    array([[-21.019, -22.13 , -23.241, -24.352],
           [-29.51 , -32.583, -35.657, -38.73 ],
           [-38.001, -43.037, -48.073, -53.109]])
    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
    array([[[-21.019,  -3.169],
            [-22.13 ,  -0.827],
            [-23.241,   1.515],
            [-24.352,   3.858]],
           [[-29.51 ,   5.224],
            [-32.583,   7.089],
            [-35.657,   8.954],
            [-38.73 ,  10.819]],
           [[-38.001,  13.617],
            [-43.037,  15.005],
            [-48.073,  16.393],
            [-53.109,  17.78 ]]])

    Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
    promjenom parametra `predict` i mijenjanja količine stanja koja se
    predviđaju.  Prije svakog poziva postavlja se *sjeme* generatora
    pseudo-slučajnih brojeva u biblioteci *NumPy*-ja zato da primjeri budu
    reproducibilni.

    &gt;&gt;&gt; def sqmean (X):
    ...     return np.sqrt(np.mean(np.square(X), axis = 0))
    ...
    &gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
    array([[ -1.494,  -3.493,  -5.493,  -7.493],
           [ -9.5  , -11.501, -13.501, -15.502],
           [-17.507, -19.508, -21.51 , -23.511]])

    Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
    primjer mogao realizirati također koristeći `lambda` funkciju).

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if (_np.isnan(Z) | _np.isinf(Z)).any():
        raise ValueError(
            &#39;Z mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(Z.shape):
            raise ValueError(
                &#39;k ne smije nadmasiti najmanju dimenziju tenzora Z.&#39;
            )

    # Saniraj parametar T0.
    if T0 is not None:
        if not isinstance(T0, _numbers.Integral):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        try:
            T0 = _copy.deepcopy(int(T0))
        except (TypeError, ValueError):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        if T0 &lt;= 0:
            raise ValueError(&#39;T0 mora biti strogo pozitivan.&#39;)
        T0 = min(T0, int(Z.shape[-1]))

    # Saniraj parametar predict.
    if predict is None:
        if ((T0 is None and Z.shape[-1] == 1) or T0 == 1) and k == 1:
            predict = lambda x : x
        else:
            predict = _functools.partial(_np.mean, axis = 0, keepdims = False)
    if not hasattr(predict, &#39;__call__&#39;):
        raise TypeError(
            &#39;Nacin predikcije mora biti zadan funkcijskim objektom.&#39;
        )

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj CP dekompoziciju tenzora Z.
    cpd = _copy.deepcopy(
        list(_parafac(Z, int(min(Z.shape)) if k is None else k))
    )
    l = _np.ones(min(Z.shape) if k is None else k, dtype = float, order = &#39;F&#39;)
    for i in iter(range(int(Z.ndim))):
        cpd[i] = _np.array(cpd[i], copy = True, order = &#39;F&#39;)
        if cpd[i].ndim &lt;= 1:
            cpd[i] = cpd[i].reshape((cpd[i].size, 1)).copy(order = &#39;F&#39;)
        for k in iter(range(int(l.size))):
            aux_N = _np.linalg.norm(cpd[i][:, k])
            if aux_N:
                l[k] *= aux_N
                cpd[i][:, k] /= aux_N
            else:
                l[k] = 0
                cpd[i][:, k] = 0
            del aux_N

    # Predvidi vrijednosti posljednje komponente.
    if T0 is not None:
        cpd[-1] = cpd[-1][int(Z.shape[-1] - T0):].copy(order = &#39;F&#39;)
    if cpd[-1].shape[1] == 1:
        cpd[-1] = cpd[-1].ravel().copy(order = &#39;F&#39;)
    if cpd[-1].size == 1:
        cpd[-1] = cpd[-1].ravel().copy(order = &#39;F&#39;)
        cpd[-1] = cpd[-1].dtype.type(cpd[-1][0])
    cpd[-1] = predict(cpd[-1])

    # Saniraj predikciju posljednje komponente.
    if not isinstance(cpd[-1], _np.ndarray):
        if not (hasattr(cpd[-1], &#39;__iter__&#39;) or hasattr(cpd[-1], &#39;__array__&#39;)):
            cpd[-1] = _np.array([cpd[-1]])
        try:
            cpd[-1] = _np.array(cpd[-1])
        except (TypeError, ValueError):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        cpd[-1].dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Predikcija mora biti tenzor numerickih vrijednosti.&#39;)
    if cpd[-1].ndim not in {1, 2}:
        raise ValueError(
            &#39;Predikcija mora biti jednodimenzionalna ili dvodimenzionalna.&#39;
        )
    if not cpd[-1].size:
        raise ValueError(&#39;Predikcija ne smije biti prazna.&#39;)
    if isinstance(cpd[-1], _np.matrix):
        cpd[-1] = cpd[-1].A
    if cpd[-1].ndim == 2:
        cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
    else:
        cpd[-1]= cpd[-1].reshape((cpd[-1].size, 1)).copy(order = &#39;C&#39;)
    if cpd[-1].shape[0] != l.size:
        if l.size == 1 and cpd[-1].shape[0] != 1:
            cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
        else:
            raise ValueError(&#39;Predikcija mora biti koliko i komponenti.&#39;)

    # Konvertiraj objekt cpd u tuple.
    cpd = tuple(cpd)

    # Ako se ne traži rekompozicija predikcije, vrati njezinu dekompoziciju.
    if not compute:
        return (l, _copy.deepcopy(cpd[:-1]), cpd[-1].T.copy(order = &#39;F&#39;))

    # Izračunaj rekompoziciju predikcije.
    # TODO: Ubrzati ovaj dio koda NumPy-jevim &#34;broadcastingom&#34;.
    aux_dim = _np.ones(max(Z.ndim - 1, 0), dtype = int, order = &#39;F&#39;)
    S = _np.zeros(
        tuple(_np.concatenate((Z.shape[:-1], [cpd[-1].shape[1]])).tolist()),
        dtype = float,
        order = &#39;F&#39;
    )
    for k in iter(range(int(l.size))):
        aux_S = l[k] * cpd[-1][k].ravel()
        aux_S = aux_S.reshape(
            tuple(_np.concatenate((aux_dim, [aux_S.size])).tolist())
        )
        for i in iter(range(int(Z.ndim - 1))):
            aux_S = (
                aux_S * cpd[i][:, k].reshape(
                    tuple(
                        _np.concatenate(([Z.shape[i]], aux_dim[i:])).tolist()
                    )
                )
            )
        S = S + aux_S
        del aux_S
    del aux_dim

    # Po potrebi redimenzioniraj predikciju ili ju pretvori u skalar.
    if isinstance(S, _np.ndarray):
        if S.shape == tuple():
            S = S.dtype.type(S)
        elif S.shape[-1] == 1:
            S = S.reshape(S.shape[:-1]).copy(order = &#39;F&#39;)
            if S.shape == tuple():
                S = S.dtype.type(S)
        else:
            S = S.copy(order = &#39;F&#39;)

    # Vrati izračunatu predikciju.
    return S

def rand_fft (n, mu = 0.0, sigma = _math.sqrt(0.5)):
    &#34;&#34;&#34;
    Generiraj koeficijente slučajnog jednodimenzionalnog Fourierovog reda.

    Funkcija normalnom distribucijom generira parametar koji se može
    proslijediti funkcijama `numpy.fft.ifft` i `numpy.fft.irfft` kao
    koeficijenti jednodimenzionalnog Fourierovog reda.

    Ako su `mu` i `sigma` `tuple`-ovi duljine 2, povratna vrijednost
    ekvivalentna je pozivu (osim što se za `n == 1` ekstrahira jedinstveni
    skalar)

    &gt;&gt;&gt; np.array(sigma[0] * np.random.randn(n) + mu[0] + (sigma[1] * np.random.randn(n) + mu[1]) * complex(0.0, 1.0), dtype = complex)

    Parametri
    ---------
    n : int in range [0, +inf)
        Broj koeficijenata koji se generiraju.

    mu : complex or (n,) array or tuple of 2 of such
        Očekivanje koeficijenata (zadana vrijednost je 0).  Ako je jedinstveni
        broj ili jedinstveni niz duljine `n`, uzima se `mu = (mu, mu)`.

    sigma : complex or (n,) array or tuple of 2 of such
        &#34;Standardna devijacija&#34; koeficijenata (zadana vrijednost je
        sqrt(2) / 2).  Može biti 0, negativno ili čak kompleksni broj s
        imaginarnim dijelom različitim od 0.  Ako je jedinstveni broj ili
        jedinstveni niz duljine `n`, uzima se `sigma = (sigma, sigma)`.

    Povratne vrijednosti
    --------------------
    F : (n,) array
        Niz od `n` kompleksnih brojeva čiji su realni i imaginarni dijelovi
        distribuirani sa zadanim parametrima.  Ako je `n == 1`, povratna
        vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `n` nije cijeli broj, parametar `mu` sadrži vrijednost koja
        nije kompleksni broj, parametar `sigma` sadrži vrijednost koja nije
        kompleksni broj.

    ValueError
        Parametar `n` je negativan, parametar `mu` sadrži niz koji nije duljine
        `n`, parametar `sigma` sadrži niz koji nije duljine `n`, parametar `mu`
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `sigma` sadrži
        nedefinirane ili beskonačne vrijednosti.

    &#34;&#34;&#34;

    # Saniraj parametar n.
    if not isinstance(n, _numbers.Integral):
        raise TypeError(&#39;n mora biti cijeli broj.&#39;)
    try:
        n = _copy.deepcopy(int(n))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;n mora biti klase int.&#39;)
    if n &lt; 0:
        raise ValueError(&#39;n mora biti nenegativan.&#39;)

    # Saniraj parametre mu i sigma.
    if not isinstance(mu, tuple):
        mu = (mu, mu)
    if not isinstance(sigma, tuple):
        sigma = (sigma, sigma)
    if len(mu) != 2:
        raise ValueError(&#39;mu mora biti dvoclani tuple.&#39;)
    if len(sigma) != 2:
        raise ValueError(&#39;sigma mora biti dvoclani tuple.&#39;)
    mu = list(mu)
    sigma = list(sigma)
    for i in iter(range(2)):
        if (
            not isinstance(mu[i], _np.ndarray) and
            (hasattr(mu[i], &#39;__iter__&#39;) or hasattr(mu[i], &#39;__array__&#39;))
        ):
            try:
                mu[i] = _np.array(mu[i])
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;mu mora biti skalar ili klase numpy.ndarray.&#39;)
        if isinstance(mu[i], _np.ndarray):
            if not issubclass(mu[i].dtype.type, _numbers.Complex):
                raise TypeError(&#39;mu mora biti niz numerickih vrijednosti.&#39;)
            if mu[i].ndim != 1:
                raise ValueError(&#39;mu mora biti jednodimenzionalni niz.&#39;)
            if mu[i].size != 1 and mu[i].size != n:
                raise ValueError(&#39;mu mora biti duljine n.&#39;)
            mu[i] = mu[i].astype(complex)
            if (_np.isnan(mu[i]) | _np.isinf(mu[i])).any():
                raise ValueError(
                    &#39;mu mora sadrzavati samo definirane i konacne vrijednosti.&#39;
                )
        else:
            if not isinstance(mu[i], _numbers.Complex):
                raise TypeError(&#39;mu mora biti numericki skalar&#39;)
            try:
                mu[i] = _copy.deepcopy(complex(mu[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;&#39;)
            if (
                _math.isnan(mu[i].real) or
                _math.isnan(mu[i].imag) or
                _math.isinf(mu[i].real) or
                _math.isinf(mu[i].imag)
            ):
                raise ValueError(&#39;mu ne smije biti NaN ili beskonacno.&#39;)
        if (
            not isinstance(sigma[i], _np.ndarray) and
            (hasattr(sigma[i], &#39;__iter__&#39;) or hasattr(sigma[i], &#39;__array__&#39;))
        ):
            try:
                sigma[i] = _np.array(sigma[i])
            except (TypeError, ValueError, AttributeError):
                raise TypeError(
                    &#39;sigma mora biti skalar ili klase numpy.ndarray.&#39;
                )
        if isinstance(sigma[i], _np.ndarray):
            if not issubclass(sigma[i].dtype.type, _numbers.Complex):
                raise TypeError(&#39;sigma mora biti niz numerickih vrijednosti.&#39;)
            if sigma[i].ndim != 1:
                raise ValueError(&#39;sigma mora biti jednodimenzionalni niz.&#39;)
            if sigma[i].size != 1 and sigma[i].size != n:
                raise ValueError(&#39;sigma mora biti duljine n.&#39;)
            sigma[i] = sigma[i].astype(complex)
            if (_np.isnan(sigma[i]) | _np.isinf(sigma[i])).any():
                raise ValueError(
                    &#39;sigma mora sadrzavati samo definirane i konacne &#39;
                    &#39;vrijednosti.&#39;
                )
        else:
            if not isinstance(sigma[i], _numbers.Complex):
                raise TypeError(&#39;sigma mora biti numericki skalar&#39;)
            try:
                sigma[i] = _copy.deepcopy(complex(sigma[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;&#39;)
            if (
                _math.isnan(sigma[i].real) or
                _math.isnan(sigma[i].imag) or
                _math.isinf(sigma[i].real) or
                _math.isinf(sigma[i].imag)
            ):
                raise ValueError(&#39;sigma ne smije biti NaN ili beskonacno.&#39;)
    mu = tuple(mu)
    sigma = tuple(sigma)

    # Generiraj &#34;realne&#34; i &#34;imaginarne&#34; dijelove koeficijenata.
    Fr = (sigma[0] * _np.random.randn(n)) + mu[0]
    Fi = (sigma[1] * _np.random.randn(n)) + mu[1]

    # Generiraj niz koeficijenata jednodimenzionalnog Fourierovog reda.
    F = _np.array(Fr + Fi * complex(0.0, 1.0), dtype = complex, order = &#39;F&#39;)

    # Po potrebi pretvori F u skalar.
    if isinstance(F, _np.ndarray):
        if F.shape == tuple():
            F = F.dtype.type(F)
        elif n == 1:
            F = F.dtype.type(F[0])

    # Vrati generirani niz F.
    return F</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tlp.bt_Katz_score"><code class="name flex">
<span>def <span class="ident">bt_Katz_score</span></span>(<span>X, beta=0.5, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated bipartite Katz score</em> matrice bliskosti.</p>
<p><em>Bipartite truncated Katz score</em> se računa po formuli iz
<a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Matrica bliskosti težinskog bipartitnog grafa.
Sve veze moraju imati
definiranu i konačnu težinu (težina je 0 ako veze nema).
Graf s vezama
bez težina realizira se vezama težine 1.
Budući da su po pretpostavci
kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
osobe, a stupci konferencije), simetričnost matrice <code>X</code> ne znači
simetričnost grafa.
Za Katzovu ocijenu neusmjerenog grafa koristi
se <a title="tlp.t_Katz_score" href="#tlp.t_Katz_score"><code>t_Katz_score()</code></a>.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> (<code>0</code>, <code>1</code>), optional</dt>
<dd>Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>M</code>, <code>N</code>)], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
bliskosti <code>X</code>; inače je povratna vrijednost Katzova ocijena matrice
bliskosti <code>X</code> (zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Score_k</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Katzova ocijena matrice bliskosti <code>X</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> istina.</dd>
<dt><strong><code>U_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
<dt><strong><code>psi_m_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>s</code> singularnih vrijednosti matrice <code>X</code> poredan silazno,
<code>psi_m_k[i]</code> iznosi
<code>beta * s[i] * (1 - beta ** 2 * s[i] ** 2) ** -1</code>.
Ova se povratna
vrijednost vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>psi_p_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>s</code> singularnih vrijednosti matrice <code>X</code> poredan silazno,
<code>psi_p_k[i]</code> iznosi
<code>(1 - beta ** 2 * s[i] ** 2) ** -1 - 1</code>.
Ova se povratna vrijednost
vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>V_k</code></strong> :&ensp;(<code>N</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>beta</code> nije
realni broj, parametar <code>k</code> nije cijeli broj, parametar <code>compute</code> nije
istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije matrica, sadrži nedefinirane ili
beskonačne vrijednosti, parametar <code>beta</code> nije u intervalu (0, 1),
parametar <code>k</code> nije u intervalu [1, <code>M</code>], parametar <code>compute</code> nije
laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.partial_svd(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="vidi-takoer">Vidi također</h2>
<dl>
<dt><strong><a title="tlp.t_Katz_score" href="#tlp.t_Katz_score"><code>t_Katz_score()</code></a></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[0, 0, 1, 1],
...      [1, 0, 0, 1],
...      [0, 1, 1, 1]]
&gt;&gt;&gt; X = np.array(X, dtype = bool)
&gt;&gt;&gt; X.astype(int)
array([[0, 0, 1, 1],


   [1, 0, 0, 1],
   [0, 1, 1, 1]])

&gt;&gt;&gt; bt_Katz_score(X).round(3)
array([[-0.545, -0.909, -1.091, -1.636],


   [ 0.364, -0.727, -1.273, -0.909],
   [-0.727, -0.545, -1.455, -2.182]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
array([[ 0.057, -0.98 , -0.054,  0.003],


   [-2.356,  1.151,  1.208, -1.148],
   [ 1.151, -0.111, -1.091,  0.06 ]])

&gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
array([[-0.476, -0.653, -1.201, -1.677],


   [ 0.351, -0.776, -1.252, -0.901],
   [-0.776, -0.724, -1.378, -2.153]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ 0.255, -0.246, -0.369, -0.114],


   [-2.393,  1.012,  1.267, -1.126],
   [ 1.012, -0.625, -0.87 ,  0.142]])
</code></pre>
<p>Katzova ocijena bipartitnog grafa bez težina.</p>
<pre><code>&gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
&gt;&gt;&gt; X /= np.abs(X).max()
&gt;&gt;&gt; X
array([[-0.   ,  0.   , -0.25 ,  0.125],


   [-1.   ,  0.   , -0.   ,  0.125],
   [-0.   ,  0.5  , -0.25 ,  0.125]])

&gt;&gt;&gt; bt_Katz_score(X).round(3)
array([[-0.003,  0.005, -0.13 ,  0.065],


   [-0.67 ,  0.001, -0.001,  0.084],
   [-0.003,  0.272, -0.139,  0.07 ]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
array([[ -0.516,   0.063,  -0.3  ,   0.214],


   [-28.756,   0.338,  -0.298,   3.744],
   [ -0.676,   0.723,  -0.393,   0.281]])

&gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
array([[-0.008,  0.072, -0.047,  0.024],


   [-0.67 ,  0.001, -0.002,  0.085],
   [-0.001,  0.253, -0.163,  0.082]])

&gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ -0.527,   0.199,  -0.13 ,   0.131],


   [-28.756,   0.337,  -0.3  ,   3.745],
   [ -0.673,   0.684,  -0.442,   0.305]])
</code></pre>
<p>Katzova ocijena bipartitnog grafa s težinama.</p>
<pre><code>&gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
&gt;&gt;&gt; U.round(3)
array([[ 0.019, -0.275],


   [ 1.   ,  0.029],
   [ 0.025, -0.961]])

&gt;&gt;&gt; psi_m.round(3)
array([0.676, 0.324])
&gt;&gt;&gt; psi_p.round(3)
array([0.341, 0.096])
&gt;&gt;&gt; V.round(3)
array([[-0.991, -0.049],


   [ 0.012, -0.812],
   [-0.011,  0.522],
   [ 0.129, -0.255]])
</code></pre>
<p>Dekompozicija Katzove ocijene bipartitnog grafa s težinama.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>score_k == U_k @ np.diag(psi_m_k) @ V_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def bt_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated bipartite Katz score* matrice bliskosti.

    *Bipartite truncated Katz score* se računa po formuli iz
    [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica bliskosti težinskog bipartitnog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.  Budući da su po pretpostavci
        kontekst redaka i stupaca različiti (na primjer, retci predstavljaju
        osobe, a stupci konferencije), simetričnost matrice `X` ne znači
        simetričnost grafa.  Za Katzovu ocijenu neusmjerenog grafa koristi
        se `t_Katz_score`.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    psi_m_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_m_k[i]` iznosi
        `beta * s[i] * (1 - beta ** 2 * s[i] ** 2) ** -1`.  Ova se povratna
        vrijednost vraća ako je `compute` laž.

    psi_p_k : (k,) array
        Za konačni niz `s` singularnih vrijednosti matrice `X` poredan silazno,
        `psi_p_k[i]` iznosi
        `(1 - beta ** 2 * s[i] ** 2) ** -1 - 1`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `beta` nije u intervalu (0, 1),
        parametar `k` nije u intervalu [1, `M`], parametar `compute` nije
        laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Vidi također
    ------------
    t_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 1, 1],
    ...      [1, 0, 0, 1],
    ...      [0, 1, 1, 1]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 1, 1],
           [1, 0, 0, 1],
           [0, 1, 1, 1]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.545, -0.909, -1.091, -1.636],
           [ 0.364, -0.727, -1.273, -0.909],
           [-0.727, -0.545, -1.455, -2.182]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 0.057, -0.98 , -0.054,  0.003],
           [-2.356,  1.151,  1.208, -1.148],
           [ 1.151, -0.111, -1.091,  0.06 ]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.476, -0.653, -1.201, -1.677],
           [ 0.351, -0.776, -1.252, -0.901],
           [-0.776, -0.724, -1.378, -2.153]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 0.255, -0.246, -0.369, -0.114],
           [-2.393,  1.012,  1.267, -1.126],
           [ 1.012, -0.625, -0.87 ,  0.142]])

    Katzova ocijena bipartitnog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X
    array([[-0.   ,  0.   , -0.25 ,  0.125],
           [-1.   ,  0.   , -0.   ,  0.125],
           [-0.   ,  0.5  , -0.25 ,  0.125]])
    &gt;&gt;&gt; bt_Katz_score(X).round(3)
    array([[-0.003,  0.005, -0.13 ,  0.065],
           [-0.67 ,  0.001, -0.001,  0.084],
           [-0.003,  0.272, -0.139,  0.07 ]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ -0.516,   0.063,  -0.3  ,   0.214],
           [-28.756,   0.338,  -0.298,   3.744],
           [ -0.676,   0.723,  -0.393,   0.281]])
    &gt;&gt;&gt; bt_Katz_score(X, k = 2).round(3)
    array([[-0.008,  0.072, -0.047,  0.024],
           [-0.67 ,  0.001, -0.002,  0.085],
           [-0.001,  0.253, -0.163,  0.082]])
    &gt;&gt;&gt; bt_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ -0.527,   0.199,  -0.13 ,   0.131],
           [-28.756,   0.337,  -0.3  ,   3.745],
           [ -0.673,   0.684,  -0.442,   0.305]])

    Katzova ocijena bipartitnog grafa s težinama.

    &gt;&gt;&gt; U, psi_m, psi_p, V = bt_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[ 0.019, -0.275],
           [ 1.   ,  0.029],
           [ 0.025, -0.961]])
    &gt;&gt;&gt; psi_m.round(3)
    array([0.676, 0.324])
    &gt;&gt;&gt; psi_p.round(3)
    array([0.341, 0.096])
    &gt;&gt;&gt; V.round(3)
    array([[-0.991, -0.049],
           [ 0.012, -0.812],
           [-0.011,  0.522],
           [ 0.129, -0.255]])

    Dekompozicija Katzove ocijene bipartitnog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == U_k @ np.diag(psi_m_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1].&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(min(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        (beta * s * (1.0 - beta ** 2 * s ** 2) ** -1).copy(order = &#39;F&#39;) * U,
        V.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else (
        U,
        beta * s * (1.0 - beta ** 2 * s ** 2) ** -1,
        (1.0 - beta ** 2 * s ** 2) ** -1 - 1.0,
        V
    )</code></pre>
</details>
</dd>
<dt id="tlp.cp_score"><code class="name flex">
<span>def <span class="ident">cp_score</span></span>(<span>Z, k=None, T0=None, predict=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>CP score</em> tenzora.</p>
<p><em>CP score</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>array</code></dt>
<dd>Tenzor numeričkih vrijednosti čiji se <em>CP score</em> računa.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>Z.shape</code>)], optional</dt>
<dd>Rang komponenti u dekompoziciji tenzora <code>Z</code> (zadana vrijednost je
<code>None</code>).
Ako je <code>None</code>, uzima se <code>k = min(Z.shape)</code>.</dd>
<dt><strong><code>T0</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, +<code>inf</code>), optional</dt>
<dd>Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
stanja (zadana vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se
<code>T0 = Z.shape[-1]</code>.</dd>
<dt><strong><code>predict</code></strong> :&ensp;<code>None</code> or <code>callable</code>, optional</dt>
<dd>Funkcija za predviđanje sljedećih stanja (zadana vrijednost je <code>None</code>).
Ako nije <code>None</code>, funkcija prima komponentu kao objekt klase
<code>numpy.ndarray</code> oblika <code>(T0, k)</code> osim ako je <code>k == 1</code> (u tom slučaju je
argument <code>numpy.ndarray</code> oblika <code>(T0,)</code> za <code>T0 != 1</code> odnosno jedinstveni
skalar za <code>T0 == 1</code>), a povratna vrijednost mora biti također
<code>numpy.array</code> oblika <code>(k,)</code> ili <code>(n, k)</code> za neki <code>n &gt; 0</code> (predviđa se
<code>n</code> sljedećih stanja); ako je <code>k == 1</code>, povratna vrijednost smije biti
jedinstveni skalar.
Ako je <code>None</code>, uzima se aritmetička sredina po
prvoj dimenziji.</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija <em>CP</em> ocijene matrice
tenzora <code>Z</code>; inače je povratna vrijednost <em>CP</em> ocijena tenzora <code>Z</code>
(zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Z_score</code></strong> :&ensp;<code>array</code></dt>
<dd><em>CP</em> ocijena zadanog tenzora <code>Z</code>.
Povratni tenzor dimenzionalnosti je
za 1 manje od tenzora <code>Z</code> ako <code>predict</code> predviđa točno jedno stanje, a
inače je dimenzionalnosti iste kao <code>Z</code>.
Prvih <code>Z.ndim - 1</code> dimenzija
jednakih je kao tenzora <code>Z</code>, a, ako <code>predict</code> predviđa <code>n &gt; 1</code> stanja,
posljednja dimenzija je veličine <code>n</code>.
Ako je predikcija array oblika
<code>()</code> ili <code>(1,)</code>, povratna vrijednost je skalar.
Ova se povratna
vrijednost vraća ako je <code>compute</code> istina.</dd>
<dt><strong><code>l</code></strong> :&ensp;(<code>Z.ndim</code>,) <code>array</code></dt>
<dd>Dekomponiramo li tenzor <code>Z</code> na tenzore <code>cp_components</code> ranga <code>k</code> tako da
je <code>j</code>-ti stupac svake komponente normiran, onda je
<code>Z = sum(l[i] * prod(cp_components[:, i]))</code>.
Ova se povratna vrijednost
vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>cpd</code></strong> :&ensp;<code>tuple</code> of <code>arrays</code></dt>
<dd><code>cpd</code> je <code>tuple</code> duljine <code>Z.ndim - 1</code>, a <code>cpd[i]</code> je, kao
<code>numpy.ndarray</code> oblika <code>(Z.shape[i], k)</code>, <code>i</code>-ta komponenta u <em>CP</em>
dekompoziciji tenzora <code>Z</code> na komponente ranga <code>k</code>; dodatno, norma svakog
stupca matrice <code>cpd[i]</code> iznosi <code>1</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> laž.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>array</code></dt>
<dd>Rezultat predikcije funkcijom <code>predict</code>.
Ako je predikcija rezultirala
jednodimenzionalnim nizom ili skalarom, <code>p</code> će ipak biti
dvodimenzionalan (druga dimenzija je veličine 1, za skalarnu predikciju
će i prva dimenzija biti veličine 1).
Ova se povratna vrijednost vraća
ako je <code>compute</code> laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>Z</code> nije tenzor numeričkih vrijednosti, parametar <code>k</code> nije
cijeli broj, parametar <code>T0</code> nije cijeli broj, parametar <code>predict</code> nema
metodu <code>__call__</code>, parametar <code>compute</code> nije istinitosna vrijednost,
predikcija nije tenzor numeričkih vrijednosti.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>Z</code> je prazni tenzor ili sadrži nedefinirane ili beskonačne
vrijednosti, parametar <code>k</code> nije u intervalu [1, <code>min(Z.shape)</code>],
parametar <code>T0</code> nije strogo pozitivan, parametar <code>compute</code> nije
laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.decomposition.parafac(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; Z = [[[ 1,  2],
...       [ 3,  4],
...       [ 5,  6],
...       [ 7,  8]],
...      [[ 9, 10],
...       [11, 12],
...       [13, 14],
...       [15, 16]],
...      [[17, 18],
...       [19, 20],
...       [21, 22],
...       [23, 24]]]
&gt;&gt;&gt; cp_score(Z).round(3)
array([[ 1.503,  3.5  ,  5.497,  7.494],


   [ 9.502, 11.5  , 13.499, 15.498],
   [17.5  , 19.5  , 21.501, 23.502]])

&gt;&gt;&gt; cp_score(Z, k = 1).round(3)
array([[ 3.836,  4.433,  5.031,  5.628],


   [10.188, 11.775, 13.362, 14.949],
   [16.54 , 19.116, 21.693, 24.269]])

&gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
array([[ 2.061,  4.009,  5.957,  7.905],


   [ 9.982, 11.99 , 13.998, 16.005],
   [17.904, 19.971, 22.038, 24.105]])

&gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
array([[ 3.955,  4.571,  5.187,  5.803],


   [10.504, 12.14 , 13.776, 15.412],
   [17.053, 19.709, 22.365, 25.021]])
</code></pre>
<p><em>CP</em> ocijena tenzora.</p>
<pre><code>&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
array([[-21.019, -22.13 , -23.241, -24.352],


   [-29.51 , -32.583, -35.657, -38.73 ],
   [-38.001, -43.037, -48.073, -53.109]])

&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
array([[[-21.019,  -3.169],


    [-22.13 ,  -0.827],
    [-23.241,   1.515],
    [-24.352,   3.858]],
   [[-29.51 ,   5.224],
    [-32.583,   7.089],
    [-35.657,   8.954],
    [-38.73 ,  10.819]],
   [[-38.001,  13.617],
    [-43.037,  15.005],
    [-48.073,  16.393],
    [-53.109,  17.78 ]]])
</code></pre>
<p>Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
promjenom parametra <code>predict</code> i mijenjanja količine stanja koja se
predviđaju.
Prije svakog poziva postavlja se <em>sjeme</em> generatora
pseudo-slučajnih brojeva u biblioteci <em>NumPy</em>-ja zato da primjeri budu
reproducibilni.</p>
<pre><code>&gt;&gt;&gt; def sqmean (X):
...     return np.sqrt(np.mean(np.square(X), axis = 0))
...
&gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
array([[ -1.494,  -3.493,  -5.493,  -7.493],


   [ -9.5  , -11.501, -13.501, -15.502],
   [-17.507, -19.508, -21.51 , -23.511]])
</code></pre>
<p>Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
primjer mogao realizirati također koristeći <code>lambda</code> funkciju).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cp_score (Z, k = None, T0 = None, predict = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *CP score* tenzora.

    *CP score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CP score* računa.

    k : None or int in range [1, min(Z.shape)], optional
        Rang komponenti u dekompoziciji tenzora `Z` (zadana vrijednost je
        `None`).  Ako je `None`, uzima se `k = min(Z.shape)`.

    T0 : None or int in range [1, +inf), optional
        Broj zadnjih stanja koji se uzima u obzir pri predviđanju sljedećih
        stanja (zadana vrijednost je `None`).  Ako je `None`, uzima se
        `T0 = Z.shape[-1]`.

    predict : None or callable, optional
        Funkcija za predviđanje sljedećih stanja (zadana vrijednost je `None`).
        Ako nije `None`, funkcija prima komponentu kao objekt klase
        `numpy.ndarray` oblika `(T0, k)` osim ako je `k == 1` (u tom slučaju je
        argument `numpy.ndarray` oblika `(T0,)` za `T0 != 1` odnosno jedinstveni
        skalar za `T0 == 1`), a povratna vrijednost mora biti također
        `numpy.array` oblika `(k,)` ili `(n, k)` za neki `n &gt; 0` (predviđa se
        `n` sljedećih stanja); ako je `k == 1`, povratna vrijednost smije biti
        jedinstveni skalar.  Ako je `None`, uzima se aritmetička sredina po
        prvoj dimenziji.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija *CP* ocijene matrice
        tenzora `Z`; inače je povratna vrijednost *CP* ocijena tenzora `Z`
        (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Z_score : array
        *CP* ocijena zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je
        za 1 manje od tenzora `Z` ako `predict` predviđa točno jedno stanje, a
        inače je dimenzionalnosti iste kao `Z`.  Prvih `Z.ndim - 1` dimenzija
        jednakih je kao tenzora `Z`, a, ako `predict` predviđa `n &gt; 1` stanja,
        posljednja dimenzija je veličine `n`.  Ako je predikcija array oblika
        `()` ili `(1,)`, povratna vrijednost je skalar.  Ova se povratna
        vrijednost vraća ako je `compute` istina.

    l : (Z.ndim,) array
        Dekomponiramo li tenzor `Z` na tenzore `cp_components` ranga `k` tako da
        je `j`-ti stupac svake komponente normiran, onda je
        `Z = sum(l[i] * prod(cp_components[:, i]))`.  Ova se povratna vrijednost
        vraća ako je `compute` laž.

    cpd : tuple of arrays
        `cpd` je `tuple` duljine `Z.ndim - 1`, a `cpd[i]` je, kao
        `numpy.ndarray` oblika `(Z.shape[i], k)`, `i`-ta komponenta u *CP*
        dekompoziciji tenzora `Z` na komponente ranga `k`; dodatno, norma svakog
        stupca matrice `cpd[i]` iznosi `1`.  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    p : array
        Rezultat predikcije funkcijom `predict`.  Ako je predikcija rezultirala
        jednodimenzionalnim nizom ili skalarom, `p` će ipak biti
        dvodimenzionalan (druga dimenzija je veličine 1, za skalarnu predikciju
        će i prva dimenzija biti veličine 1).  Ova se povratna vrijednost vraća
        ako je `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `T0` nije cijeli broj, parametar `predict` nema
        metodu `__call__`, parametar `compute` nije istinitosna vrijednost,
        predikcija nije tenzor numeričkih vrijednosti.

    ValueError
        Parametar `Z` je prazni tenzor ili sadrži nedefinirane ili beskonačne
        vrijednosti, parametar `k` nije u intervalu [1, `min(Z.shape)`],
        parametar `T0` nije strogo pozitivan, parametar `compute` nije
        laž/istina, predikcija nije niz/matrica odgovarajućih dimenzija.

    other
        Iznimke izbačene pozivom `tl.decomposition.parafac(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cp_score(Z).round(3)
    array([[ 1.503,  3.5  ,  5.497,  7.494],
           [ 9.502, 11.5  , 13.499, 15.498],
           [17.5  , 19.5  , 21.501, 23.502]])
    &gt;&gt;&gt; cp_score(Z, k = 1).round(3)
    array([[ 3.836,  4.433,  5.031,  5.628],
           [10.188, 11.775, 13.362, 14.949],
           [16.54 , 19.116, 21.693, 24.269]])
    &gt;&gt;&gt; cp_score(Z, T0 = 1).round(3)
    array([[ 2.061,  4.009,  5.957,  7.905],
           [ 9.982, 11.99 , 13.998, 16.005],
           [17.904, 19.971, 22.038, 24.105]])
    &gt;&gt;&gt; cp_score(Z, k = 1, T0 = 1).round(3)
    array([[ 3.955,  4.571,  5.187,  5.803],
           [10.504, 12.14 , 13.776, 15.412],
           [17.053, 19.709, 22.365, 25.021]])

    *CP* ocijena tenzora.

    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(X.shape[-1])).round(3)
    array([[-21.019, -22.13 , -23.241, -24.352],
           [-29.51 , -32.583, -35.657, -38.73 ],
           [-38.001, -43.037, -48.073, -53.109]])
    &gt;&gt;&gt; np.random.seed(1)
    &gt;&gt;&gt; cp_score(Z, predict = lambda X : np.random.randn(*X.shape)).round(3)
    array([[[-21.019,  -3.169],
            [-22.13 ,  -0.827],
            [-23.241,   1.515],
            [-24.352,   3.858]],
           [[-29.51 ,   5.224],
            [-32.583,   7.089],
            [-35.657,   8.954],
            [-38.73 ,  10.819]],
           [[-38.001,  13.617],
            [-43.037,  15.005],
            [-48.073,  16.393],
            [-53.109,  17.78 ]]])

    Ovaj primjer nema stvarnog smisla, osim što demonstrira način poziva s
    promjenom parametra `predict` i mijenjanja količine stanja koja se
    predviđaju.  Prije svakog poziva postavlja se *sjeme* generatora
    pseudo-slučajnih brojeva u biblioteci *NumPy*-ja zato da primjeri budu
    reproducibilni.

    &gt;&gt;&gt; def sqmean (X):
    ...     return np.sqrt(np.mean(np.square(X), axis = 0))
    ...
    &gt;&gt;&gt; cp_score(Z, predict = sqmean).round(3)
    array([[ -1.494,  -3.493,  -5.493,  -7.493],
           [ -9.5  , -11.501, -13.501, -15.502],
           [-17.507, -19.508, -21.51 , -23.511]])

    Primjer kako koristiti vlastitu, složeniju funkciju predikcije (iako se ovaj
    primjer mogao realizirati također koristeći `lambda` funkciju).

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if (_np.isnan(Z) | _np.isinf(Z)).any():
        raise ValueError(
            &#39;Z mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(Z.shape):
            raise ValueError(
                &#39;k ne smije nadmasiti najmanju dimenziju tenzora Z.&#39;
            )

    # Saniraj parametar T0.
    if T0 is not None:
        if not isinstance(T0, _numbers.Integral):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        try:
            T0 = _copy.deepcopy(int(T0))
        except (TypeError, ValueError):
            raise TypeError(&#39;T0 mora biti None ili klase int.&#39;)
        if T0 &lt;= 0:
            raise ValueError(&#39;T0 mora biti strogo pozitivan.&#39;)
        T0 = min(T0, int(Z.shape[-1]))

    # Saniraj parametar predict.
    if predict is None:
        if ((T0 is None and Z.shape[-1] == 1) or T0 == 1) and k == 1:
            predict = lambda x : x
        else:
            predict = _functools.partial(_np.mean, axis = 0, keepdims = False)
    if not hasattr(predict, &#39;__call__&#39;):
        raise TypeError(
            &#39;Nacin predikcije mora biti zadan funkcijskim objektom.&#39;
        )

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj CP dekompoziciju tenzora Z.
    cpd = _copy.deepcopy(
        list(_parafac(Z, int(min(Z.shape)) if k is None else k))
    )
    l = _np.ones(min(Z.shape) if k is None else k, dtype = float, order = &#39;F&#39;)
    for i in iter(range(int(Z.ndim))):
        cpd[i] = _np.array(cpd[i], copy = True, order = &#39;F&#39;)
        if cpd[i].ndim &lt;= 1:
            cpd[i] = cpd[i].reshape((cpd[i].size, 1)).copy(order = &#39;F&#39;)
        for k in iter(range(int(l.size))):
            aux_N = _np.linalg.norm(cpd[i][:, k])
            if aux_N:
                l[k] *= aux_N
                cpd[i][:, k] /= aux_N
            else:
                l[k] = 0
                cpd[i][:, k] = 0
            del aux_N

    # Predvidi vrijednosti posljednje komponente.
    if T0 is not None:
        cpd[-1] = cpd[-1][int(Z.shape[-1] - T0):].copy(order = &#39;F&#39;)
    if cpd[-1].shape[1] == 1:
        cpd[-1] = cpd[-1].ravel().copy(order = &#39;F&#39;)
    if cpd[-1].size == 1:
        cpd[-1] = cpd[-1].ravel().copy(order = &#39;F&#39;)
        cpd[-1] = cpd[-1].dtype.type(cpd[-1][0])
    cpd[-1] = predict(cpd[-1])

    # Saniraj predikciju posljednje komponente.
    if not isinstance(cpd[-1], _np.ndarray):
        if not (hasattr(cpd[-1], &#39;__iter__&#39;) or hasattr(cpd[-1], &#39;__array__&#39;)):
            cpd[-1] = _np.array([cpd[-1]])
        try:
            cpd[-1] = _np.array(cpd[-1])
        except (TypeError, ValueError):
            raise TypeError(&#39;Predikcija mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        cpd[-1].dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Predikcija mora biti tenzor numerickih vrijednosti.&#39;)
    if cpd[-1].ndim not in {1, 2}:
        raise ValueError(
            &#39;Predikcija mora biti jednodimenzionalna ili dvodimenzionalna.&#39;
        )
    if not cpd[-1].size:
        raise ValueError(&#39;Predikcija ne smije biti prazna.&#39;)
    if isinstance(cpd[-1], _np.matrix):
        cpd[-1] = cpd[-1].A
    if cpd[-1].ndim == 2:
        cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
    else:
        cpd[-1]= cpd[-1].reshape((cpd[-1].size, 1)).copy(order = &#39;C&#39;)
    if cpd[-1].shape[0] != l.size:
        if l.size == 1 and cpd[-1].shape[0] != 1:
            cpd[-1] = cpd[-1].T.copy(order = &#39;C&#39;)
        else:
            raise ValueError(&#39;Predikcija mora biti koliko i komponenti.&#39;)

    # Konvertiraj objekt cpd u tuple.
    cpd = tuple(cpd)

    # Ako se ne traži rekompozicija predikcije, vrati njezinu dekompoziciju.
    if not compute:
        return (l, _copy.deepcopy(cpd[:-1]), cpd[-1].T.copy(order = &#39;F&#39;))

    # Izračunaj rekompoziciju predikcije.
    # TODO: Ubrzati ovaj dio koda NumPy-jevim &#34;broadcastingom&#34;.
    aux_dim = _np.ones(max(Z.ndim - 1, 0), dtype = int, order = &#39;F&#39;)
    S = _np.zeros(
        tuple(_np.concatenate((Z.shape[:-1], [cpd[-1].shape[1]])).tolist()),
        dtype = float,
        order = &#39;F&#39;
    )
    for k in iter(range(int(l.size))):
        aux_S = l[k] * cpd[-1][k].ravel()
        aux_S = aux_S.reshape(
            tuple(_np.concatenate((aux_dim, [aux_S.size])).tolist())
        )
        for i in iter(range(int(Z.ndim - 1))):
            aux_S = (
                aux_S * cpd[i][:, k].reshape(
                    tuple(
                        _np.concatenate(([Z.shape[i]], aux_dim[i:])).tolist()
                    )
                )
            )
        S = S + aux_S
        del aux_S
    del aux_dim

    # Po potrebi redimenzioniraj predikciju ili ju pretvori u skalar.
    if isinstance(S, _np.ndarray):
        if S.shape == tuple():
            S = S.dtype.type(S)
        elif S.shape[-1] == 1:
            S = S.reshape(S.shape[:-1]).copy(order = &#39;F&#39;)
            if S.shape == tuple():
                S = S.dtype.type(S)
        else:
            S = S.copy(order = &#39;F&#39;)

    # Vrati izračunatu predikciju.
    return S</code></pre>
</details>
</dd>
<dt id="tlp.cwt"><code class="name flex">
<span>def <span class="ident">cwt</span></span>(<span>Z, theta=0.5, norm=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>collapsed weighted tensor</em> (<em>CWT</em>).</p>
<p><em>CWT</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>array</code></dt>
<dd>Tenzor numeričkih vrijednosti čiji se <em>CWT</em> računa.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> [<code>0</code> <code>to</code> <code>1</code>), optional</dt>
<dd>Parametar <em>gubitka</em> relevantnosti stanja kroz vrijeme (zadana vrijednost
je 0.5).</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
to jest, povratna vrijednost je podijeljena sa
<code>sum((1 - theta) ** i for i in range(Z.shape[-1]))</code> (zadana vrijednost
je laž).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Z_cwt</code></strong> :&ensp;<code>array</code></dt>
<dd><em>CWT</em> zadanog tenzora <code>Z</code>.
Povratni tenzor dimenzionalnosti je za 1
manje od tenzora <code>Z</code>, a oblikom je jednak obliku <code>Z.shape[:-1]</code>.
Ako je
<code>Z</code> jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>Z</code> nije tenzor numeričkih vrijednosti, parametar <code>theta</code> nije
realni broj.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>Z</code> je skalar ili prazni tenzor, parametar <code>theta</code> nije u
intervalu [0, 1).</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; Z = [[[ 1,  2],
...       [ 3,  4],
...       [ 5,  6],
...       [ 7,  8]],
...      [[ 9, 10],
...       [11, 12],
...       [13, 14],
...       [15, 16]],
...      [[17, 18],
...       [19, 20],
...       [21, 22],
...       [23, 24]]]
&gt;&gt;&gt; cwt(Z)
array([[ 2.5,  5.5,  8.5, 11.5],


   [14.5, 17.5, 20.5, 23.5],
   [26.5, 29.5, 32.5, 35.5]])

&gt;&gt;&gt; cwt(Z, theta = 0.0)
array([[ 3.,  7., 11., 15.],


   [19., 23., 27., 31.],
   [35., 39., 43., 47.]])

&gt;&gt;&gt; cwt(Z, norm = True).round(3)
array([[ 1.667,  3.667,  5.667,  7.667],


   [ 9.667, 11.667, 13.667, 15.667],
   [17.667, 19.667, 21.667, 23.667]])

&gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
array([[ 1.5,  3.5,  5.5,  7.5],


   [ 9.5, 11.5, 13.5, 15.5],
   [17.5, 19.5, 21.5, 23.5]])
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cwt (Z, theta = 0.5, norm = False):
    &#34;&#34;&#34;
    Izračunaj *collapsed weighted tensor* (*CWT*).

    *CWT* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    Z : array
        Tenzor numeričkih vrijednosti čiji se *CWT* računa.

    theta : float in range [0 to 1), optional
        Parametar *gubitka* relevantnosti stanja kroz vrijeme (zadana vrijednost
        je 0.5).

    norm : boolean, optional
        Ako je istina, povratni tenzor je težinska sredina umjesto obične sume,
        to jest, povratna vrijednost je podijeljena sa
        `sum((1 - theta) ** i for i in range(Z.shape[-1]))` (zadana vrijednost
        je laž).

    Povratne vrijednosti
    --------------------
    Z_cwt : array
        *CWT* zadanog tenzora `Z`.  Povratni tenzor dimenzionalnosti je za 1
        manje od tenzora `Z`, a oblikom je jednak obliku `Z.shape[:-1]`.  Ako je
        `Z` jednodimenzionalni tenzor (vektor), povratna vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `Z` nije tenzor numeričkih vrijednosti, parametar `theta` nije
        realni broj.

    ValueError
        Parametar `Z` je skalar ili prazni tenzor, parametar `theta` nije u
        intervalu [0, 1).

    Primjeri
    --------
    &gt;&gt;&gt; Z = [[[ 1,  2],
    ...       [ 3,  4],
    ...       [ 5,  6],
    ...       [ 7,  8]],
    ...      [[ 9, 10],
    ...       [11, 12],
    ...       [13, 14],
    ...       [15, 16]],
    ...      [[17, 18],
    ...       [19, 20],
    ...       [21, 22],
    ...       [23, 24]]]
    &gt;&gt;&gt; cwt(Z)
    array([[ 2.5,  5.5,  8.5, 11.5],
           [14.5, 17.5, 20.5, 23.5],
           [26.5, 29.5, 32.5, 35.5]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0)
    array([[ 3.,  7., 11., 15.],
           [19., 23., 27., 31.],
           [35., 39., 43., 47.]])
    &gt;&gt;&gt; cwt(Z, norm = True).round(3)
    array([[ 1.667,  3.667,  5.667,  7.667],
           [ 9.667, 11.667, 13.667, 15.667],
           [17.667, 19.667, 21.667, 23.667]])
    &gt;&gt;&gt; cwt(Z, theta = 0.0, norm = True)
    array([[ 1.5,  3.5,  5.5,  7.5],
           [ 9.5, 11.5, 13.5, 15.5],
           [17.5, 19.5, 21.5, 23.5]])

    &#34;&#34;&#34;

    # Saniraj parametar Z.
    if not isinstance(Z, _np.ndarray):
        if not (hasattr(Z, &#39;__iter__&#39;) or hasattr(Z, &#39;__array__&#39;)):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
        try:
            Z = _np.array(Z)
        except (TypeError, ValueError):
            raise TypeError(&#39;Z mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        Z.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Z mora biti tenzor numerickih vrijednosti.&#39;)
    if not Z.ndim:
        raise ValueError(&#39;Z mora biti barem jednodimenzionalni tenzor.&#39;)
    if not Z.size:
        raise ValueError(&#39;Z mora biti neprazni tenzor.&#39;)
    if isinstance(Z, _np.matrix):
        Z = Z.A
    if issubclass(
        Z.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        Z = Z.astype(float)

    # Saniraj parametar theta.
    if not isinstance(theta, _numbers.Real):
        raise TypeError(&#39;theta mora biti realni broj.&#39;)
    try:
        theta = _copy.deepcopy(float(theta))
    except (TypeError, ValueError):
        raise TypeError(&#39;theta mora biti klase float.&#39;)
    if _math.isnan(theta) or _math.isinf(theta):
        raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
    if not (theta &gt;= 0.0 and theta &lt; 1.0):
        raise ValueError(&#39;theta mora biti u intervalu [0, 1).&#39;)

    # Saniraj parametar norm.
    if not isinstance(
        norm,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)
    if norm not in {0, False, 1, True}:
        raise ValueError(&#39;norm mora biti laz/istina.&#39;)
    try:
        norm = _copy.deepcopy(bool(norm))
    except (TypeError, ValueError):
        raise TypeError(&#39;norm mora biti klase bool.&#39;)

    # Izračunaj prvih Z.shape[-1] elemenata geometrijskog niza s koeficijentom
    # 1 - theta.
    one_min_theta = _np.flip(
        (1.0 - theta) ** _np.arange(Z.shape[-1], dtype = int)
    ).copy(order = &#39;F&#39;)

    # Izračunaj kompresijsku sumu.
    Z_compressed = (one_min_theta * Z).sum(axis = -1).copy(order = &#39;F&#39;)

    # Ako je norm istina, podijeli kompresijsku sumu sa _theta.sum().
    if norm:
        Z_compressed /= one_min_theta.sum()

    # Po potrebi pretvori Z u skalar.
    if isinstance(Z_compressed, _np.ndarray):
        if Z_compressed.shape == tuple():
            Z_compressed = Z_compressed.dtype.type(Z_compressed)

    # Vrati kompresijsku sumu.
    return Z_compressed</code></pre>
</details>
</dd>
<dt id="tlp.rand_fft"><code class="name flex">
<span>def <span class="ident">rand_fft</span></span>(<span>n, mu=0.0, sigma=0.7071067811865476)</span>
</code></dt>
<dd>
<section class="desc"><p>Generiraj koeficijente slučajnog jednodimenzionalnog Fourierovog reda.</p>
<p>Funkcija normalnom distribucijom generira parametar koji se može
proslijediti funkcijama <code>numpy.fft.ifft</code> i <code>numpy.fft.irfft</code> kao
koeficijenti jednodimenzionalnog Fourierovog reda.</p>
<p>Ako su <code>mu</code> i <code>sigma</code> <code>tuple</code>-ovi duljine 2, povratna vrijednost
ekvivalentna je pozivu (osim što se za <code>n == 1</code> ekstrahira jedinstveni
skalar)</p>
<pre><code>&gt;&gt;&gt; np.array(sigma[0] * np.random.randn(n) + mu[0] + (sigma[1] * np.random.randn(n) + mu[1]) * complex(0.0, 1.0), dtype = complex)
</code></pre>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>0</code>, +<code>inf</code>)</dt>
<dd>Broj koeficijenata koji se generiraju.</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>complex</code> or (<code>n</code>,) <code>array</code> or <code>tuple</code> of <code>2</code> of <code>such</code></dt>
<dd>Očekivanje koeficijenata (zadana vrijednost je 0).
Ako je jedinstveni
broj ili jedinstveni niz duljine <code>n</code>, uzima se <code>mu = (mu, mu)</code>.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>complex</code> or (<code>n</code>,) <code>array</code> or <code>tuple</code> of <code>2</code> of <code>such</code></dt>
<dd>"Standardna devijacija" koeficijenata (zadana vrijednost je
sqrt(2) / 2).
Može biti 0, negativno ili čak kompleksni broj s
imaginarnim dijelom različitim od 0.
Ako je jedinstveni broj ili
jedinstveni niz duljine <code>n</code>, uzima se <code>sigma = (sigma, sigma)</code>.</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>F</code></strong> :&ensp;(<code>n</code>,) <code>array</code></dt>
<dd>Niz od <code>n</code> kompleksnih brojeva čiji su realni i imaginarni dijelovi
distribuirani sa zadanim parametrima.
Ako je <code>n == 1</code>, povratna
vrijednost je skalar.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>n</code> nije cijeli broj, parametar <code>mu</code> sadrži vrijednost koja
nije kompleksni broj, parametar <code>sigma</code> sadrži vrijednost koja nije
kompleksni broj.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>n</code> je negativan, parametar <code>mu</code> sadrži niz koji nije duljine
<code>n</code>, parametar <code>sigma</code> sadrži niz koji nije duljine <code>n</code>, parametar <code>mu</code>
sadrži nedefinirane ili beskonačne vrijednosti, parametar <code>sigma</code> sadrži
nedefinirane ili beskonačne vrijednosti.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rand_fft (n, mu = 0.0, sigma = _math.sqrt(0.5)):
    &#34;&#34;&#34;
    Generiraj koeficijente slučajnog jednodimenzionalnog Fourierovog reda.

    Funkcija normalnom distribucijom generira parametar koji se može
    proslijediti funkcijama `numpy.fft.ifft` i `numpy.fft.irfft` kao
    koeficijenti jednodimenzionalnog Fourierovog reda.

    Ako su `mu` i `sigma` `tuple`-ovi duljine 2, povratna vrijednost
    ekvivalentna je pozivu (osim što se za `n == 1` ekstrahira jedinstveni
    skalar)

    &gt;&gt;&gt; np.array(sigma[0] * np.random.randn(n) + mu[0] + (sigma[1] * np.random.randn(n) + mu[1]) * complex(0.0, 1.0), dtype = complex)

    Parametri
    ---------
    n : int in range [0, +inf)
        Broj koeficijenata koji se generiraju.

    mu : complex or (n,) array or tuple of 2 of such
        Očekivanje koeficijenata (zadana vrijednost je 0).  Ako je jedinstveni
        broj ili jedinstveni niz duljine `n`, uzima se `mu = (mu, mu)`.

    sigma : complex or (n,) array or tuple of 2 of such
        &#34;Standardna devijacija&#34; koeficijenata (zadana vrijednost je
        sqrt(2) / 2).  Može biti 0, negativno ili čak kompleksni broj s
        imaginarnim dijelom različitim od 0.  Ako je jedinstveni broj ili
        jedinstveni niz duljine `n`, uzima se `sigma = (sigma, sigma)`.

    Povratne vrijednosti
    --------------------
    F : (n,) array
        Niz od `n` kompleksnih brojeva čiji su realni i imaginarni dijelovi
        distribuirani sa zadanim parametrima.  Ako je `n == 1`, povratna
        vrijednost je skalar.

    Iznimke
    -------
    TypeError
        Parametar `n` nije cijeli broj, parametar `mu` sadrži vrijednost koja
        nije kompleksni broj, parametar `sigma` sadrži vrijednost koja nije
        kompleksni broj.

    ValueError
        Parametar `n` je negativan, parametar `mu` sadrži niz koji nije duljine
        `n`, parametar `sigma` sadrži niz koji nije duljine `n`, parametar `mu`
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `sigma` sadrži
        nedefinirane ili beskonačne vrijednosti.

    &#34;&#34;&#34;

    # Saniraj parametar n.
    if not isinstance(n, _numbers.Integral):
        raise TypeError(&#39;n mora biti cijeli broj.&#39;)
    try:
        n = _copy.deepcopy(int(n))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;n mora biti klase int.&#39;)
    if n &lt; 0:
        raise ValueError(&#39;n mora biti nenegativan.&#39;)

    # Saniraj parametre mu i sigma.
    if not isinstance(mu, tuple):
        mu = (mu, mu)
    if not isinstance(sigma, tuple):
        sigma = (sigma, sigma)
    if len(mu) != 2:
        raise ValueError(&#39;mu mora biti dvoclani tuple.&#39;)
    if len(sigma) != 2:
        raise ValueError(&#39;sigma mora biti dvoclani tuple.&#39;)
    mu = list(mu)
    sigma = list(sigma)
    for i in iter(range(2)):
        if (
            not isinstance(mu[i], _np.ndarray) and
            (hasattr(mu[i], &#39;__iter__&#39;) or hasattr(mu[i], &#39;__array__&#39;))
        ):
            try:
                mu[i] = _np.array(mu[i])
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;mu mora biti skalar ili klase numpy.ndarray.&#39;)
        if isinstance(mu[i], _np.ndarray):
            if not issubclass(mu[i].dtype.type, _numbers.Complex):
                raise TypeError(&#39;mu mora biti niz numerickih vrijednosti.&#39;)
            if mu[i].ndim != 1:
                raise ValueError(&#39;mu mora biti jednodimenzionalni niz.&#39;)
            if mu[i].size != 1 and mu[i].size != n:
                raise ValueError(&#39;mu mora biti duljine n.&#39;)
            mu[i] = mu[i].astype(complex)
            if (_np.isnan(mu[i]) | _np.isinf(mu[i])).any():
                raise ValueError(
                    &#39;mu mora sadrzavati samo definirane i konacne vrijednosti.&#39;
                )
        else:
            if not isinstance(mu[i], _numbers.Complex):
                raise TypeError(&#39;mu mora biti numericki skalar&#39;)
            try:
                mu[i] = _copy.deepcopy(complex(mu[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;&#39;)
            if (
                _math.isnan(mu[i].real) or
                _math.isnan(mu[i].imag) or
                _math.isinf(mu[i].real) or
                _math.isinf(mu[i].imag)
            ):
                raise ValueError(&#39;mu ne smije biti NaN ili beskonacno.&#39;)
        if (
            not isinstance(sigma[i], _np.ndarray) and
            (hasattr(sigma[i], &#39;__iter__&#39;) or hasattr(sigma[i], &#39;__array__&#39;))
        ):
            try:
                sigma[i] = _np.array(sigma[i])
            except (TypeError, ValueError, AttributeError):
                raise TypeError(
                    &#39;sigma mora biti skalar ili klase numpy.ndarray.&#39;
                )
        if isinstance(sigma[i], _np.ndarray):
            if not issubclass(sigma[i].dtype.type, _numbers.Complex):
                raise TypeError(&#39;sigma mora biti niz numerickih vrijednosti.&#39;)
            if sigma[i].ndim != 1:
                raise ValueError(&#39;sigma mora biti jednodimenzionalni niz.&#39;)
            if sigma[i].size != 1 and sigma[i].size != n:
                raise ValueError(&#39;sigma mora biti duljine n.&#39;)
            sigma[i] = sigma[i].astype(complex)
            if (_np.isnan(sigma[i]) | _np.isinf(sigma[i])).any():
                raise ValueError(
                    &#39;sigma mora sadrzavati samo definirane i konacne &#39;
                    &#39;vrijednosti.&#39;
                )
        else:
            if not isinstance(sigma[i], _numbers.Complex):
                raise TypeError(&#39;sigma mora biti numericki skalar&#39;)
            try:
                sigma[i] = _copy.deepcopy(complex(sigma[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;&#39;)
            if (
                _math.isnan(sigma[i].real) or
                _math.isnan(sigma[i].imag) or
                _math.isinf(sigma[i].real) or
                _math.isinf(sigma[i].imag)
            ):
                raise ValueError(&#39;sigma ne smije biti NaN ili beskonacno.&#39;)
    mu = tuple(mu)
    sigma = tuple(sigma)

    # Generiraj &#34;realne&#34; i &#34;imaginarne&#34; dijelove koeficijenata.
    Fr = (sigma[0] * _np.random.randn(n)) + mu[0]
    Fi = (sigma[1] * _np.random.randn(n)) + mu[1]

    # Generiraj niz koeficijenata jednodimenzionalnog Fourierovog reda.
    F = _np.array(Fr + Fi * complex(0.0, 1.0), dtype = complex, order = &#39;F&#39;)

    # Po potrebi pretvori F u skalar.
    if isinstance(F, _np.ndarray):
        if F.shape == tuple():
            F = F.dtype.type(F)
        elif n == 1:
            F = F.dtype.type(F[0])

    # Vrati generirani niz F.
    return F</code></pre>
</details>
</dd>
<dt id="tlp.t_Katz_score"><code class="name flex">
<span>def <span class="ident">t_Katz_score</span></span>(<span>X, beta=0.5, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated Katz score</em> kvadratne simetrične matrice bliskosti.</p>
<p><em>Truncated Katz score</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>M</code>) <code>symmetric</code> <code>array</code></dt>
<dd>Matrica bliskosti neusmjerenog težinskog grafa.
Sve veze moraju imati
definiranu i konačnu težinu (težina je 0 ako veze nema).
Graf s vezama
bez težina realizira se vezama težine 1.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> (<code>0</code>, <code>1</code>), optional</dt>
<dd>Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>M</code>], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
bliskosti <code>X</code>; inače je povratna vrijednost Katzova ocijena matrice
bliskosti <code>X</code> (zadana vrijednost je istina).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>Score_k</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Katzova ocijena matrice bliskosti <code>X</code>.
Ova se povratna vrijednost vraća
ako je <code>compute</code> istina.</dd>
<dt><strong><code>gamma_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd>Za konačni niz <code>l</code> svojstvenih vrijednosti matrice <code>X</code> poredan silazno
po apsolutnoj vrijednosti, <code>gamma_k[i]</code> iznosi
<code>(1 - beta * l[i]) ** -1 - 1</code>.
Ova se povratna vrijednost vraća ako je
<code>compute</code> laž.</dd>
<dt><strong><code>W_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Matrica normiranih stupaca.
Ova se povratna vrijednost vraća ako je
<code>compute</code> laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>beta</code> nije
realni broj, parametar <code>k</code> nije cijeli broj, parametar <code>compute</code> nije
istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije kvadratna simetrična matrica,
sadrži nedefinirane ili beskonačne vrijednosti, parametar <code>beta</code> nije u
intervalu (0, 1), parametar <code>k</code> nije u intervalu [1, <code>M</code>], parametar
<code>compute</code> nije laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>np.linalg.eig(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="vidi-takoer">Vidi također</h2>
<dl>
<dt><strong><a title="tlp.bt_Katz_score" href="#tlp.bt_Katz_score"><code>bt_Katz_score()</code></a></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[0, 0, 0, 1],
...      [0, 0, 1, 0],
...      [0, 0, 0, 1],
...      [0, 0, 0, 0]]
&gt;&gt;&gt; X = np.array(X, dtype = bool)
&gt;&gt;&gt; X |= X.T
&gt;&gt;&gt; X.astype(int)
array([[0, 0, 0, 1],


   [0, 0, 1, 0],
   [0, 1, 0, 1],
   [1, 0, 1, 0]])

&gt;&gt;&gt; t_Katz_score(X).round(3)
array([[0.6, 0.4, 0.8, 1.2],


   [0.4, 0.6, 1.2, 0.8],
   [0.8, 1.2, 1.4, 1.6],
   [1.2, 0.8, 1.6, 1.4]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
array([[-0.05 , -0.978, -1.003, -0.051],


   [-0.978, -0.05 , -0.051, -1.003],
   [-1.003, -0.051, -1.052, -1.028],
   [-0.051, -1.003, -1.028, -1.052]])

&gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
array([[0.524, 0.647, 0.847, 1.047],


   [0.647, 0.524, 1.047, 0.847],
   [0.847, 1.047, 1.371, 1.694],
   [1.047, 0.847, 1.694, 1.371]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[-0.462, -0.293, -0.748, -0.474],


   [-0.293, -0.462, -0.474, -0.748],
   [-0.748, -0.474, -1.21 , -0.767],
   [-0.474, -0.748, -0.767, -1.21 ]])
</code></pre>
<p>Katzova ocijena neusmjerenog grafa bez težina.</p>
<pre><code>&gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
&gt;&gt;&gt; X += X.T
&gt;&gt;&gt; X /= np.abs(X).max()
&gt;&gt;&gt; X.round(3)
array([[-0.   ,  0.   , -0.   , -1.   ],


   [ 0.   ,  0.   ,  0.286,  0.   ],
   [-0.   ,  0.286, -0.   , -0.143],
   [-1.   ,  0.   , -0.143,  0.   ]])

&gt;&gt;&gt; t_Katz_score(X).round(3)
array([[ 0.336,  0.007,  0.049, -0.671],


   [ 0.007,  0.021,  0.147, -0.014],
   [ 0.049,  0.147,  0.028, -0.098],
   [-0.671, -0.014, -0.098,  0.343]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
array([[ 33.541,   1.447,   5.195, -34.401],


   [  1.447,   0.147,   0.526,  -1.484],
   [  5.195,   0.526,   0.889,  -5.328],
   [-34.401,  -1.484,  -5.328,  34.283]])

&gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
array([[ 0.335,  0.029,  0.052, -0.67 ],


   [ 0.029,  0.001,  0.005, -0.015],
   [ 0.052,  0.005,  0.008, -0.104],
   [-0.67 , -0.015, -0.104,  0.343]])

&gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
array([[ 33.539,   1.493,   5.207, -34.399],


   [  1.493,   0.065,   0.232,  -1.488],
   [  5.207,   0.232,   0.808,  -5.341],
   [-34.399,  -1.488,  -5.341,  34.283]])
</code></pre>
<p>Katzova ocijena neusmjerenog grafa s težinama.</p>
<pre><code>&gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
&gt;&gt;&gt; gamma.round(3)
array([-0.336,  1.022])
&gt;&gt;&gt; W.round(3)
array([[-0.699,  0.699],


   [ 0.031,  0.031],
   [-0.108,  0.108],
   [-0.706, -0.706]])
</code></pre>
<p>Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>score_k == W_k @ np.diag(gamma_k) @ W_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def t_Katz_score (X, beta = 0.5, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated Katz score* kvadratne simetrične matrice bliskosti.

    *Truncated Katz score* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, M) symmetric array
        Matrica bliskosti neusmjerenog težinskog grafa.  Sve veze moraju imati
        definiranu i konačnu težinu (težina je 0 ako veze nema).  Graf s vezama
        bez težina realizira se vezama težine 1.

    beta : float in range (0, 1), optional
        Koeficijent relevantnosti duljih puteva (zadana vrijednost je 0.5).

    k : None or int in range [1, M], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija Katzove ocijene matrice
        bliskosti `X`; inače je povratna vrijednost Katzova ocijena matrice
        bliskosti `X` (zadana vrijednost je istina).

    Povratne vrijednosti
    --------------------
    Score_k : (M, N) array
        Katzova ocijena matrice bliskosti `X`.  Ova se povratna vrijednost vraća
        ako je `compute` istina.

    gamma_k : (k,) array
        Za konačni niz `l` svojstvenih vrijednosti matrice `X` poredan silazno
        po apsolutnoj vrijednosti, `gamma_k[i]` iznosi
        `(1 - beta * l[i]) ** -1 - 1`.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    W_k : (M, k) array
        Matrica normiranih stupaca.  Ova se povratna vrijednost vraća ako je
        `compute` laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `beta` nije
        realni broj, parametar `k` nije cijeli broj, parametar `compute` nije
        istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije kvadratna simetrična matrica,
        sadrži nedefinirane ili beskonačne vrijednosti, parametar `beta` nije u
        intervalu (0, 1), parametar `k` nije u intervalu [1, `M`], parametar
        `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `np.linalg.eig(...)` ne hvataju se.

    Vidi također
    ------------
    bt_Katz_score

    Primjeri
    --------
    &gt;&gt;&gt; X = [[0, 0, 0, 1],
    ...      [0, 0, 1, 0],
    ...      [0, 0, 0, 1],
    ...      [0, 0, 0, 0]]
    &gt;&gt;&gt; X = np.array(X, dtype = bool)
    &gt;&gt;&gt; X |= X.T
    &gt;&gt;&gt; X.astype(int)
    array([[0, 0, 0, 1],
           [0, 0, 1, 0],
           [0, 1, 0, 1],
           [1, 0, 1, 0]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[0.6, 0.4, 0.8, 1.2],
           [0.4, 0.6, 1.2, 0.8],
           [0.8, 1.2, 1.4, 1.6],
           [1.2, 0.8, 1.6, 1.4]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[-0.05 , -0.978, -1.003, -0.051],
           [-0.978, -0.05 , -0.051, -1.003],
           [-1.003, -0.051, -1.052, -1.028],
           [-0.051, -1.003, -1.028, -1.052]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[0.524, 0.647, 0.847, 1.047],
           [0.647, 0.524, 1.047, 0.847],
           [0.847, 1.047, 1.371, 1.694],
           [1.047, 0.847, 1.694, 1.371]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[-0.462, -0.293, -0.748, -0.474],
           [-0.293, -0.462, -0.474, -0.748],
           [-0.748, -0.474, -1.21 , -0.767],
           [-0.474, -0.748, -0.767, -1.21 ]])

    Katzova ocijena neusmjerenog grafa bez težina.

    &gt;&gt;&gt; X = X * [-2.0 ** -i for i in range(1, 5)]
    &gt;&gt;&gt; X += X.T
    &gt;&gt;&gt; X /= np.abs(X).max()
    &gt;&gt;&gt; X.round(3)
    array([[-0.   ,  0.   , -0.   , -1.   ],
           [ 0.   ,  0.   ,  0.286,  0.   ],
           [-0.   ,  0.286, -0.   , -0.143],
           [-1.   ,  0.   , -0.143,  0.   ]])
    &gt;&gt;&gt; t_Katz_score(X).round(3)
    array([[ 0.336,  0.007,  0.049, -0.671],
           [ 0.007,  0.021,  0.147, -0.014],
           [ 0.049,  0.147,  0.028, -0.098],
           [-0.671, -0.014, -0.098,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1).round(3)
    array([[ 33.541,   1.447,   5.195, -34.401],
           [  1.447,   0.147,   0.526,  -1.484],
           [  5.195,   0.526,   0.889,  -5.328],
           [-34.401,  -1.484,  -5.328,  34.283]])
    &gt;&gt;&gt; t_Katz_score(X, k = 2).round(3)
    array([[ 0.335,  0.029,  0.052, -0.67 ],
           [ 0.029,  0.001,  0.005, -0.015],
           [ 0.052,  0.005,  0.008, -0.104],
           [-0.67 , -0.015, -0.104,  0.343]])
    &gt;&gt;&gt; t_Katz_score(X, beta = 9.75e-1, k = 2).round(3)
    array([[ 33.539,   1.493,   5.207, -34.399],
           [  1.493,   0.065,   0.232,  -1.488],
           [  5.207,   0.232,   0.808,  -5.341],
           [-34.399,  -1.488,  -5.341,  34.283]])

    Katzova ocijena neusmjerenog grafa s težinama.

    &gt;&gt;&gt; gamma, W = t_Katz_score(X, k = 2, compute = False)
    &gt;&gt;&gt; gamma.round(3)
    array([-0.336,  1.022])
    &gt;&gt;&gt; W.round(3)
    array([[-0.699,  0.699],
           [ 0.031,  0.031],
           [-0.108,  0.108],
           [-0.706, -0.706]])

    Dekompozicija Katzove ocijene neusmjerenog grafa s težinama.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `score_k == W_k @ np.diag(gamma_k) @ W_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if X.shape[0] != X.shape[1]:
        raise ValueError(&#39;X mora biti kvadratna matrica.&#39;)
    if not _np.array_equal(X, X.T):
        raise ValueError(&#39;X mora biti simetricna matrica.&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar beta.
    if not isinstance(beta, _numbers.Real):
        raise TypeError(&#39;beta mora biti realni broj.&#39;)
    try:
        beta = _copy.deepcopy(float(beta))
    except (TypeError, ValueError):
        raise TypeError(&#39;beta mora biti klase float.&#39;)
    if _math.isnan(beta) or _math.isinf(beta):
        raise ValueError(&#39;beta ne smije biti NaN ili beskonacno.&#39;)
    if not (beta &gt; 0.0 and beta &lt; 1.0):
        raise ValueError(&#39;beta mora biti u intervalu (0, 1).&#39;)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; min(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti dimenzije matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj dekompoziciju Katzove ocijene.
    l, W = _np.linalg.eig(X)
    I = _np.flip(_np.argsort(_np.abs(l))).copy(order = &#39;F&#39;)
    l = _np.array(l[I], copy = True, order = &#39;F&#39;)
    W = _np.array(W[:, I], copy = True, order = &#39;F&#39;)
    del I
    if k is None:
        k = (
            1 if _np.isclose(1.0, 1.0 + l[0])
                else int((~_np.isclose(1.0, 1.0 + l / l[0])).sum())
        )
    l = l[:k].copy(order = &#39;F&#39;)
    W = W[:, :k].copy(order = &#39;F&#39;)

    # Vrati Katzovu ocijenu ili njezinu dekompoziciju ovisno o vrijednosti
    # parametra compute.
    return _np.matmul(
        ((1.0 - beta * l) ** -1 - 1.0).copy(order = &#39;F&#39;) * W,
        W.T.copy(order = &#39;F&#39;)
    ).copy(order = &#39;F&#39;) if compute else ((1.0 - beta * l) ** -1 - 1.0, W)</code></pre>
</details>
</dd>
<dt id="tlp.tsvd"><code class="name flex">
<span>def <span class="ident">tsvd</span></span>(<span>X, k=None, compute=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Izračunaj <em>truncated singular value decomposition</em> (<em>TSVD</em>) matrice bliskosti.</p>
<p><em>TSVD</em> se računa po formuli iz <a href="#bib-dunlavy-10">[1]</a>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code></dt>
<dd>Matrica numeričkih definiranih i konačnih vrijednosti.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>None</code> or <code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>min</code>(<code>M</code>, <code>N</code>)], optional</dt>
<dd>
<p>Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
vrijednost je <code>None</code>).
Ako je <code>None</code>, uzima se</p>
<ol>
<li>ako su sve singularne vrijednosti blizu 0, uzima se <code>k = 1</code>,</li>
<li>inače se uzima <code>k</code> = # singularnih vrijednosti čiji kvocijent s
najvećom nije blizu 0.</li>
</ol>
<p>Vrijednost <code>a</code> je blizu 0 ako vrijedi <code>np.isclose(1, 1 + a)</code>.</p>
</dd>
<dt><strong><code>compute</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Ako je laž, povratna vrijednost je dekompozicija matrice <code>X</code> na prvih
<code>k</code> singularnih vrijednosti; inače je povratna vrijednost rekompozicija
(zadana vrijednost je laž).</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>X_k</code></strong> :&ensp;(<code>M</code>, <code>M</code>) <code>array</code></dt>
<dd>Rekompozicija iz <em>TSVD</em> matrice <code>X</code> na prvih <code>k</code> singularnih
vrijednosti.
Ova se povratna vrijednost vraća ako je <code>compute</code> istina.</dd>
<dt><strong><code>U_k</code></strong> :&ensp;(<code>M</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
<dt><strong><code>s_k</code></strong> :&ensp;(<code>k</code>,) <code>array</code></dt>
<dd><code>k</code> najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
se povratna vrijednost vraća ako je <code>compute</code> laž.</dd>
<dt><strong><code>V_k</code></strong> :&ensp;(<code>N</code>, <code>k</code>) <code>array</code></dt>
<dd>Ortogonalna matrica.
Ova se povratna vrijednost vraća ako je <code>compute</code>
laž.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>X</code> nije tenzor numeričkih vrijednosti, parametar <code>k</code> nije
cijeli broj, parametar <code>compute</code> nije istinitosna vrijednost.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>X</code> je prazni tenzor, nije matrica, sadrži nedefinirane ili
beskonačne vrijednosti, parametar <code>k</code> nije u intervalu [1, min(M, N)],
parametar <code>compute</code> nije laž/istina.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Iznimke izbačene pozivom <code>tl.partial_svd(...)</code> ne hvataju se.</dd>
</dl>
<h2 id="primjeri">Primjeri</h2>
<pre><code>&gt;&gt;&gt; X = [[ 1,  5,  0, -2],
...      [-2,  4,  0,  1],
...      [ 0, -1, -1,  0]]
&gt;&gt;&gt; tsvd(X).round(3)
array([[ 1.,  5., -0., -2.],


   [-2.,  4.,  0.,  1.],
   [ 0., -1., -1., -0.]])

&gt;&gt;&gt; tsvd(X, k = 1).round(3)
array([[-0.321,  5.1  ,  0.121, -0.769],


   [-0.243,  3.869,  0.092, -0.584],
   [ 0.063, -0.997, -0.024,  0.15 ]])

&gt;&gt;&gt; tsvd(X, k = 2).round(3)
array([[ 1.012,  5.   ,  0.108, -1.988],


   [-1.988,  4.   ,  0.108,  1.012],
   [ 0.108, -1.   , -0.024,  0.108]])
</code></pre>
<p>Rekompozicija matrice.</p>
<pre><code>&gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
&gt;&gt;&gt; U.round(3)
array([[-0.787, -0.607],


   [-0.597,  0.794],
   [ 0.154, -0.021]])

&gt;&gt;&gt; s.round(3)
array([6.566, 2.98 ])
&gt;&gt;&gt; V.round(3)
array([[ 0.062, -0.737],


   [-0.987,  0.055],
   [-0.023,  0.007],
   [ 0.149,  0.674]])
</code></pre>
<p>Dekompozicija matrice <code>X</code>.</p>
<h2 id="zabiljeske">Zabilješke</h2>
<p>Za opisane povratne vrijednosti, vrijedi
<code>X_k == U_k @ np.diag(s_k) @ V_k.T</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tsvd (X, k = None, compute = True):
    &#34;&#34;&#34;
    Izračunaj *truncated singular value decomposition* (*TSVD*) matrice bliskosti.

    *TSVD* se računa po formuli iz [[1]](#bib-dunlavy-10).

    Parametri
    ---------
    X : (M, N) array
        Matrica numeričkih definiranih i konačnih vrijednosti.

    k : None or int in range [1, min(M, N)], optional
        Broj singularnih vrijednosti matrice X za računanje ocijene (zadana
        vrijednost je `None`).  Ako je `None`, uzima se

        1.  ako su sve singularne vrijednosti blizu 0, uzima se `k = 1`,
        2.  inače se uzima `k` = # singularnih vrijednosti čiji kvocijent s
            najvećom nije blizu 0.

        Vrijednost `a` je blizu 0 ako vrijedi `np.isclose(1, 1 + a)`.

    compute : boolean, optional
        Ako je laž, povratna vrijednost je dekompozicija matrice `X` na prvih
        `k` singularnih vrijednosti; inače je povratna vrijednost rekompozicija
        (zadana vrijednost je laž).

    Povratne vrijednosti
    --------------------
    X_k : (M, M) array
        Rekompozicija iz *TSVD* matrice `X` na prvih `k` singularnih
        vrijednosti.  Ova se povratna vrijednost vraća ako je `compute` istina.

    U_k : (M, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    s_k : (k,) array
        `k` najvećih singularnih vrijednosti (poredanih u silaznom poretku). Ova
        se povratna vrijednost vraća ako je `compute` laž.

    V_k : (N, k) array
        Ortogonalna matrica.  Ova se povratna vrijednost vraća ako je `compute`
        laž.

    Iznimke
    -------
    TypeError
        Parametar `X` nije tenzor numeričkih vrijednosti, parametar `k` nije
        cijeli broj, parametar `compute` nije istinitosna vrijednost.

    ValueError
        Parametar `X` je prazni tenzor, nije matrica, sadrži nedefinirane ili
        beskonačne vrijednosti, parametar `k` nije u intervalu [1, min(M, N)],
        parametar `compute` nije laž/istina.

    other
        Iznimke izbačene pozivom `tl.partial_svd(...)` ne hvataju se.

    Primjeri
    --------
    &gt;&gt;&gt; X = [[ 1,  5,  0, -2],
    ...      [-2,  4,  0,  1],
    ...      [ 0, -1, -1,  0]]
    &gt;&gt;&gt; tsvd(X).round(3)
    array([[ 1.,  5., -0., -2.],
           [-2.,  4.,  0.,  1.],
           [ 0., -1., -1., -0.]])
    &gt;&gt;&gt; tsvd(X, k = 1).round(3)
    array([[-0.321,  5.1  ,  0.121, -0.769],
           [-0.243,  3.869,  0.092, -0.584],
           [ 0.063, -0.997, -0.024,  0.15 ]])
    &gt;&gt;&gt; tsvd(X, k = 2).round(3)
    array([[ 1.012,  5.   ,  0.108, -1.988],
           [-1.988,  4.   ,  0.108,  1.012],
           [ 0.108, -1.   , -0.024,  0.108]])

    Rekompozicija matrice.

    &gt;&gt;&gt; U, s, V = tsvd(X, k = 2, compute = False)
    &gt;&gt;&gt; U.round(3)
    array([[-0.787, -0.607],
           [-0.597,  0.794],
           [ 0.154, -0.021]])
    &gt;&gt;&gt; s.round(3)
    array([6.566, 2.98 ])
    &gt;&gt;&gt; V.round(3)
    array([[ 0.062, -0.737],
           [-0.987,  0.055],
           [-0.023,  0.007],
           [ 0.149,  0.674]])

    Dekompozicija matrice `X`.

    Zabilješke
    ----------
    Za opisane povratne vrijednosti, vrijedi
    `X_k == U_k @ np.diag(s_k) @ V_k.T`.

    &#34;&#34;&#34;

    # Saniraj parametar X.
    if not isinstance(X, _np.ndarray):
        if not (hasattr(X, &#39;__iter__&#39;) or hasattr(X, &#39;__array__&#39;)):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
        try:
            X = _np.array(X)
        except (TypeError, ValueError):
            raise TypeError(&#39;X mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        X.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;X mora biti tenzor numerickih vrijednosti.&#39;)
    if not X.size:
        raise ValueError(&#39;X mora biti neprazni tenzor.&#39;)
    if (_np.isnan(X) | _np.isinf(X)).any():
        raise ValueError(
            &#39;X mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if X.ndim != 2:
        raise ValueError(&#39;X mora biti matrica (dvodimenzionalni tenzor).&#39;)
    if isinstance(X, _np.matrix):
        X = X.A
    if issubclass(
        X.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        X = X.astype(float)

    # Saniraj parametar k.
    if k is not None:
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError):
            raise TypeError(&#39;k mora biti None ili klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)
        if k &gt; max(X.shape):
            raise ValueError(&#39;k ne smije nadmasiti manju dimenziju matrice X.&#39;)

    # Saniraj parametar compute.
    if not isinstance(
        compute,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)
    if compute not in {0, False, 1, True}:
        raise ValueError(&#39;compute mora biti laz/istina.&#39;)
    try:
        compute = _copy.deepcopy(bool(compute))
    except (TypeError, ValueError):
        raise TypeError(&#39;compute mora biti klase bool.&#39;)

    # Izračunaj TSVD.
    U = None
    s = None
    V = None
    if k is None:
        U, s, V = _tl.partial_svd(X, int(max(X.shape)))
        k = (
            1 if _np.isclose(1.0, 1.0 + s[0])
                else int((~_np.isclose(1.0, 1.0 + s / s[0])).sum())
        )
        U = _np.array(U[:, :k], copy = True, order = &#39;F&#39;)
        s = _np.array(s[:k], copy = True, order = &#39;F&#39;)
        V = _np.array(V[:k, :].T, copy = True, order = &#39;F&#39;)
    else:
        U, s, V = _tl.partial_svd(X, n_eigenvecs = k)
        U = _np.array(U, copy = True, order = &#39;F&#39;)
        s = _np.array(s, copy = True, order = &#39;F&#39;)
        V = _np.array(V.T, copy = True, order = &#39;F&#39;)

    # Vrati dekompoziciju ili rekompoziciju ovisno o vrijednosti parametra
    # compute.
    return (
        _np.matmul(s * U, V.T.copy(order = &#39;F&#39;)).copy(order = &#39;F&#39;) if compute
            else (U, s, V)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tlp.ExponentialSmooth"><code class="flex name class">
<span>class <span class="ident">ExponentialSmooth</span></span>
</code></dt>
<dd>
<section class="desc"><p>Prognoza numeričkih podataka trostrukim eksponencijalnim izglađivanjem.</p>
<p>Prognoza se računa formulama opisanim u [<a href="#bib-trubetskoy-16">2</a>].</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ExponentialSmooth (object):
    &#34;&#34;&#34;
    Prognoza numeričkih podataka trostrukim eksponencijalnim izglađivanjem.

    Prognoza se računa formulama opisanim u [[2](#bib-trubetskoy-16)].

    &#34;&#34;&#34;

    def __new__ (cls):
        # Saniraj parametar cls.
        if not issubclass(cls, ExponentialSmooth):
            raise TypeError(&#39;cls mora biti ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = super(ExponentialSmooth, cls).__new__(cls)

        # Vrati novi objekt.
        return instance

    def __init__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Inicijaliziraj self.
        super(ExponentialSmooth, self).__init__()

        # Inicijaliziraj atribute objekta self.
        self._a = _np.zeros(tuple([0]), dtype = float, order = &#39;F&#39;)
        self._n = 0
        self._b = 0.0
        self._s = _np.zeros(tuple([0]), dtype = float, order = &#39;F&#39;)

    def __copy__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = ExponentialSmooth()

        # Postavi atribute novog objekta na atribute objekta self.
        instance._a = self._a
        instance._n = self._n
        instance._b = self._b
        instance._s = self._s

        # Vrati novi objekt.
        return instance

    def __deepcopy__ (self, memo = dict()):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Kreiraj novi objekt klase ExponentialSmooth.
        instance = ExponentialSmooth()

        # Kopiraj atribute objekta self u atribute novog objekta.
        instance._a = _copy.deepcopy(self._a, memo)
        instance._n = _copy.deepcopy(self._n, memo)
        instance._b = _copy.deepcopy(self._b, memo)
        instance._s = _copy.deepcopy(self._s, memo)

        # Vrati novi objekt.
        return instance

    def __repr__ (self):
        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati tekstualnu reprezentaciju objekta self.
        return &#39;&lt;{class_name:s}: ({series_shape:s}; {season_length:d})&gt;&#39;.format(
            class_name = self.__class__.__name__,
            series_shape = repr(tuple(self._a.shape)),
            season_length = self._n
        )

    def fit (self, a, n):
        &#34;&#34;&#34;
        Pripremi prognoziranje vrijednosti tenzora `a` s periodom duljine `n`.

        Parametri
        ---------
        a : array
            Tenzor čije prognoze će se računati (po zadnjoj dimenziji).

        n : int in range [1, a.shape[-1] // 2]
            Duljina perioda u tenzoru `a`.

        Povratne vrijednosti
        --------------------
        self : ExponentialSmooth
            Povratna vrijednost je `self`.

        Iznimke
        -------
        TypeError
            Parametar `a` nije nije tenzor numeričkih vrijednosti, parametar `n`
            nije vijeli broj.

        ValueError
            Parametar `a` je prazni tenzor, sadrži nedefinrane ili beskonačne
            vrijednosti, parametar `n` nije u intervalu [1, `a.shape[-1] // 2`].

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Saniraj parametar a.
        if not isinstance(a, _np.ndarray):
            if not (hasattr(a, &#39;__iter__&#39;) or hasattr(a, &#39;__array__&#39;)):
                raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
            try:
                a = _np.array(a)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
        if not issubclass(
            a.dtype.type,
            (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
        ):
            raise TypeError(&#39;a mora biti tenzor numerickih vrijednosti.&#39;)
        if not a.ndim:
            raise ValueError(&#39;a mora biti barem jednodimenzionalni tenzor.&#39;)
        if not a.size:
            raise ValueError(&#39;a mora biti neprazni tenzor.&#39;)
        if (_np.isnan(a) | _np.isinf(a)).any():
            raise ValueError(
                &#39;a mora sadrzavati samo definirane i konacne vrijednosti.&#39;
            )
        if isinstance(a, _np.matrix):
            a = a.A

        # Saniraj parametar n.
        if not isinstance(n, _numbers.Integral):
            raise TypeError(&#39;n mora biti klase int.&#39;)
        try:
            n = _copy.deepcopy(int(n))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;n mora biti klase int.&#39;)
        if n &lt;= 0:
            raise ValueError(&#39;n mora biti strogo pozitivan.&#39;)
        if n &gt; a.shape[-1] // 2:
            raise ValueError(&#39;n ne smije biti veci od a.shape[-1] // 2.&#39;)

        # Spremi kopije parametara u atribute objekta self.  Jednostavnosti
        # računa radi, posljednja dimenzija tenzora a prebacuje se na prvo
        # mjesto.
        self._a = _np.moveaxis(a, -1, 0).copy(order = &#39;F&#39;)
        self._n = _copy.deepcopy(n)

        # Izračunaj pomoćne varijable broj cijelih perioda u tenzoru a i srednje
        # vrijednosti perioda.
        N = int(_math.floor(float(self._a.shape[0]) / self._n))
        avg = _np.array(
            [
                self._a[
                    i * self._n:_np.minimum((i + 1) * self._n, self._a.shape[0])
                ].mean(axis = 0) for i in iter(range(N))
            ],
            order = &#39;F&#39;
        )

        # Izračunaj (i spremi u atribute objekta self) inicijalni trend i
        # inicijalne sezonalne komponente tenzora a.
        self._b = (
            (self._a[self._n:2 * self._n] - self._a[:self._n]).sum() /
            float(self._n) ** 2
        )
        if isinstance(self._b, _np.ndarray):
            if self._b.shape == tuple():
                self._b = self._b.dtype.type(self._b)
        self._s = _np.array(
            [
                (self._a[i:N * self._n:self._n] - avg).sum(axis = 0)
                    for i in iter(range(self._n))
            ],
            order = &#39;F&#39;
        ) / float(N)

        # Vrati self.
        return self

    def predict (self, k = 1, theta = 0.5):
        &#34;&#34;&#34;
        Predvidi vrijednosti tenzora.

        Parametri
        ---------
        k : int in range [1, +inf), optional
            Broj vrijednosti koje se predviđa (zadana vrijednost je 1).

        theta : float in range [0, 1] or tuple of 3 floats in range [0, 1]
            Parametri eksponencijalnog izglađivanja (zadana vrijednost je 0.5).
            Ako je jedinstvena vrijednost, uzima se
            `theta = (theta, theta, theta)`.  Vrijednost `theta[0]` koeficijent
            je izglađivanja visine, vrijednost `theta[1]` koeficijent je
            izglađivanja trenda, a vrijednost `theta[2]` je koeficijent
            izglađivanja sezonalnih komponenti.

        Povratne vrijednosti
        --------------------
        y : array
            Predviđenih `k` vrijednosti tenzora `a`.  Prvih `a.ndim - 1`
            dimenzija jednakih je veličina kao tenzora `a`, a posljednja
            dimenzija je veličine `k`.  Ako je `k == 1`, onda je povratna
            vrijednost dimenzionalnosti `a.ndim - 1`.  Ako je `a`
            jednodimenzionalni tenzor i `k == 1`, onda je povratna vrijednost
            skalar.

        Iznimke
        -------
        TypeError
            Parametar `k` nije realni broj, parametar `theta` sadrži vrijednost
            koja nije realni broj.

        ValueError
            Parametar `k` nije u intervalu [1, +inf), parametar `theta` sadrži
            vrijednost koja nije u intervalu [0, 1].

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Saniraj parametar k.
        if not isinstance(k, _numbers.Integral):
            raise TypeError(&#39;k mora biti klase int.&#39;)
        try:
            k = _copy.deepcopy(int(k))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;k mora biti klase int.&#39;)
        if k &lt;= 0:
            raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)

        # Saniraj parametar theta.
        if not isinstance(theta, tuple):
            theta = _copy.deepcopy((theta, theta, theta))
        if len(theta) != 3:
            raise ValueError(&#39;theta mora biti troclani tuple.&#39;)
        theta = list(theta)
        for i in iter(range(3)):
            if not (isinstance(theta[i], _numbers.Real)):
                raise TypeError(&#39;theta mora biti klase float.&#39;)
            try:
                theta[i] = _copy.deepcopy(float(theta[i]))
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;theta mora biti klase float.&#39;)
            if _math.isnan(theta[i]) or _math.isinf(theta[i]):
                raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
            if theta[i] &lt; 0.0 or theta[i] &gt; 1.0:
                raise ValueError(&#39;theta mora biti u intervalu [0, 1].&#39;)
        theta = tuple(theta)

        # Izračunaj 1 - theta po komponentama.
        one_min_theta = (1.0 - theta[0], 1.0 - theta[1], 1.0 - theta[2])

        # Eksponencijalnim izglađivanjem izračunaj tenzor y duljine
        # a.shape[-1] + k.
        y = None
        if self._a.ndim == 1:
            y = _np.zeros(self._a.size + k, dtype = self._s.dtype, order = &#39;F&#39;)
        else:
            y = _np.zeros(
                tuple(
                    _np.concatenate(
                        ([self._a.shape[0] + k], self._a.shape[1:])
                    ).tolist()
                ),
                dtype = self._s.dtype,
                order = &#39;F&#39;
        )
        b = _copy.deepcopy(self._b)
        s = _copy.deepcopy(self._s)
        l = (_copy.deepcopy(self._a[0]), _copy.deepcopy(self._a[0]))
        for i in iter(range(1, int(self._a.shape[0]))):
            val = _copy.deepcopy(self._a[i])
            l = (
                l[1],
                (
                    theta[0] * (val - s[i % self._n]) +
                    one_min_theta[0] * (l[1] + b)
                )
            )
            b = theta[1] * (l[1] - l[0]) + one_min_theta[1] * b
            s[i % self._n] = (
                theta[2] * (val - l[1]) + one_min_theta[2] * s[i % self._n]
            )
            y[i] = l[1] + b + s[i % self._n]
        for i in iter(range(int(self._a.shape[0]), int(y.shape[0]))):
            y[i] = (l[1] + (i - self._a.shape[0] + 1) * b) + s[i % self._n]

        # Spremi samo posljednjih k vrijednosti u tenzoru y.
        y = y[int(self._a.shape[0]):].copy(order = &#39;F&#39;)

        # Po potrebi pojednostavi dimenzionalnost tenzora y odnosno pretvori ga
        # u skalar.
        if isinstance(y, _np.ndarray):
            if k == 1:
                if y.ndim == 1:
                    y = y.dtype.type(y)
                else:
                    y.shape = y.shape[1:]
            else:
                y = _np.moveaxis(y, 0, -1).copy(order = &#39;F&#39;)

        # Vrati izračunati tenzor y.
        return y

    @property
    def series_ (self):
        &#34;&#34;&#34;
        Tenzor čije prognoze se računaju eksponencijalnim izglađivanjem.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati tenzor.
        return _np.moveaxis(self._a, 0, -1).copy(order = &#39;F&#39;)

    @property
    def season_length_ (self):
        &#34;&#34;&#34;
        Duljina perioda vrijednosti tenzora.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati duljinu perioda tenzora.
        return _copy.deepcopy(self._n)

    @property
    def initial_trend_ (self):
        &#34;&#34;&#34;
        Inicijalni trend tenzora.

        &#34;&#34;&#34;

        # Saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati inicijalni trend tenzora.
        return _copy.deepcopy(self._b)

    @property
    def initial_seasonal_components_ (self):
        &#34;&#34;&#34;
        Inicijalne sezonalne komponente tenzora.

        &#34;&#34;&#34;

        # saniraj parametar self.
        if not isinstance(self, ExponentialSmooth):
            raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

        # Vrati inicijalne sezonalne komponente tenzora.
        return _copy.deepcopy(self._s)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tlp.ExponentialSmooth.initial_seasonal_components_"><code class="name">var <span class="ident">initial_seasonal_components_</span></code></dt>
<dd>
<section class="desc"><p>Inicijalne sezonalne komponente tenzora.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def initial_seasonal_components_ (self):
    &#34;&#34;&#34;
    Inicijalne sezonalne komponente tenzora.

    &#34;&#34;&#34;

    # saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Vrati inicijalne sezonalne komponente tenzora.
    return _copy.deepcopy(self._s)</code></pre>
</details>
</dd>
<dt id="tlp.ExponentialSmooth.initial_trend_"><code class="name">var <span class="ident">initial_trend_</span></code></dt>
<dd>
<section class="desc"><p>Inicijalni trend tenzora.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def initial_trend_ (self):
    &#34;&#34;&#34;
    Inicijalni trend tenzora.

    &#34;&#34;&#34;

    # Saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Vrati inicijalni trend tenzora.
    return _copy.deepcopy(self._b)</code></pre>
</details>
</dd>
<dt id="tlp.ExponentialSmooth.season_length_"><code class="name">var <span class="ident">season_length_</span></code></dt>
<dd>
<section class="desc"><p>Duljina perioda vrijednosti tenzora.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def season_length_ (self):
    &#34;&#34;&#34;
    Duljina perioda vrijednosti tenzora.

    &#34;&#34;&#34;

    # Saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Vrati duljinu perioda tenzora.
    return _copy.deepcopy(self._n)</code></pre>
</details>
</dd>
<dt id="tlp.ExponentialSmooth.series_"><code class="name">var <span class="ident">series_</span></code></dt>
<dd>
<section class="desc"><p>Tenzor čije prognoze se računaju eksponencijalnim izglađivanjem.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def series_ (self):
    &#34;&#34;&#34;
    Tenzor čije prognoze se računaju eksponencijalnim izglađivanjem.

    &#34;&#34;&#34;

    # Saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Vrati tenzor.
    return _np.moveaxis(self._a, 0, -1).copy(order = &#39;F&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tlp.ExponentialSmooth.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, a, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Pripremi prognoziranje vrijednosti tenzora <code>a</code> s periodom duljine <code>n</code>.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>array</code></dt>
<dd>Tenzor čije prognoze će se računati (po zadnjoj dimenziji).</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>a.shape</code>[-<code>1</code>] // <code>2</code>]</dt>
<dd>Duljina perioda u tenzoru <code>a</code>.</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<a title="tlp.ExponentialSmooth" href="#tlp.ExponentialSmooth"><code>ExponentialSmooth</code></a></dt>
<dd>Povratna vrijednost je <code>self</code>.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>a</code> nije nije tenzor numeričkih vrijednosti, parametar <code>n</code>
nije vijeli broj.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>a</code> je prazni tenzor, sadrži nedefinrane ili beskonačne
vrijednosti, parametar <code>n</code> nije u intervalu [1, <code>a.shape[-1] // 2</code>].</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fit (self, a, n):
    &#34;&#34;&#34;
    Pripremi prognoziranje vrijednosti tenzora `a` s periodom duljine `n`.

    Parametri
    ---------
    a : array
        Tenzor čije prognoze će se računati (po zadnjoj dimenziji).

    n : int in range [1, a.shape[-1] // 2]
        Duljina perioda u tenzoru `a`.

    Povratne vrijednosti
    --------------------
    self : ExponentialSmooth
        Povratna vrijednost je `self`.

    Iznimke
    -------
    TypeError
        Parametar `a` nije nije tenzor numeričkih vrijednosti, parametar `n`
        nije vijeli broj.

    ValueError
        Parametar `a` je prazni tenzor, sadrži nedefinrane ili beskonačne
        vrijednosti, parametar `n` nije u intervalu [1, `a.shape[-1] // 2`].

    &#34;&#34;&#34;

    # Saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Saniraj parametar a.
    if not isinstance(a, _np.ndarray):
        if not (hasattr(a, &#39;__iter__&#39;) or hasattr(a, &#39;__array__&#39;)):
            raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
        try:
            a = _np.array(a)
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;a mora biti klase numpy.ndarray.&#39;)
    if not issubclass(
        a.dtype.type,
        (_numbers.Complex, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;a mora biti tenzor numerickih vrijednosti.&#39;)
    if not a.ndim:
        raise ValueError(&#39;a mora biti barem jednodimenzionalni tenzor.&#39;)
    if not a.size:
        raise ValueError(&#39;a mora biti neprazni tenzor.&#39;)
    if (_np.isnan(a) | _np.isinf(a)).any():
        raise ValueError(
            &#39;a mora sadrzavati samo definirane i konacne vrijednosti.&#39;
        )
    if isinstance(a, _np.matrix):
        a = a.A

    # Saniraj parametar n.
    if not isinstance(n, _numbers.Integral):
        raise TypeError(&#39;n mora biti klase int.&#39;)
    try:
        n = _copy.deepcopy(int(n))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;n mora biti klase int.&#39;)
    if n &lt;= 0:
        raise ValueError(&#39;n mora biti strogo pozitivan.&#39;)
    if n &gt; a.shape[-1] // 2:
        raise ValueError(&#39;n ne smije biti veci od a.shape[-1] // 2.&#39;)

    # Spremi kopije parametara u atribute objekta self.  Jednostavnosti
    # računa radi, posljednja dimenzija tenzora a prebacuje se na prvo
    # mjesto.
    self._a = _np.moveaxis(a, -1, 0).copy(order = &#39;F&#39;)
    self._n = _copy.deepcopy(n)

    # Izračunaj pomoćne varijable broj cijelih perioda u tenzoru a i srednje
    # vrijednosti perioda.
    N = int(_math.floor(float(self._a.shape[0]) / self._n))
    avg = _np.array(
        [
            self._a[
                i * self._n:_np.minimum((i + 1) * self._n, self._a.shape[0])
            ].mean(axis = 0) for i in iter(range(N))
        ],
        order = &#39;F&#39;
    )

    # Izračunaj (i spremi u atribute objekta self) inicijalni trend i
    # inicijalne sezonalne komponente tenzora a.
    self._b = (
        (self._a[self._n:2 * self._n] - self._a[:self._n]).sum() /
        float(self._n) ** 2
    )
    if isinstance(self._b, _np.ndarray):
        if self._b.shape == tuple():
            self._b = self._b.dtype.type(self._b)
    self._s = _np.array(
        [
            (self._a[i:N * self._n:self._n] - avg).sum(axis = 0)
                for i in iter(range(self._n))
        ],
        order = &#39;F&#39;
    ) / float(N)

    # Vrati self.
    return self</code></pre>
</details>
</dd>
<dt id="tlp.ExponentialSmooth.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, k=1, theta=0.5)</span>
</code></dt>
<dd>
<section class="desc"><p>Predvidi vrijednosti tenzora.</p>
<h2 id="parametri">Parametri</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>1</code>, +<code>inf</code>), optional</dt>
<dd>Broj vrijednosti koje se predviđa (zadana vrijednost je 1).</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code> <code>in</code> <code>range</code> [<code>0</code>, <code>1</code>] or <code>tuple</code> of <code>3</code> <code>floats</code> <code>in</code> <code>range</code> [<code>0</code>, <code>1</code>]</dt>
<dd>Parametri eksponencijalnog izglađivanja (zadana vrijednost je 0.5).
Ako je jedinstvena vrijednost, uzima se
<code>theta = (theta, theta, theta)</code>.
Vrijednost <code>theta[0]</code> koeficijent
je izglađivanja visine, vrijednost <code>theta[1]</code> koeficijent je
izglađivanja trenda, a vrijednost <code>theta[2]</code> je koeficijent
izglađivanja sezonalnih komponenti.</dd>
</dl>
<h2 id="povratne-vrijednosti">Povratne vrijednosti</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code></dt>
<dd>Predviđenih <code>k</code> vrijednosti tenzora <code>a</code>.
Prvih <code>a.ndim - 1</code>
dimenzija jednakih je veličina kao tenzora <code>a</code>, a posljednja
dimenzija je veličine <code>k</code>.
Ako je <code>k == 1</code>, onda je povratna
vrijednost dimenzionalnosti <code>a.ndim - 1</code>.
Ako je <code>a</code>
jednodimenzionalni tenzor i <code>k == 1</code>, onda je povratna vrijednost
skalar.</dd>
</dl>
<h2 id="iznimke">Iznimke</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>Parametar <code>k</code> nije realni broj, parametar <code>theta</code> sadrži vrijednost
koja nije realni broj.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>Parametar <code>k</code> nije u intervalu [1, +inf), parametar <code>theta</code> sadrži
vrijednost koja nije u intervalu [0, 1].</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def predict (self, k = 1, theta = 0.5):
    &#34;&#34;&#34;
    Predvidi vrijednosti tenzora.

    Parametri
    ---------
    k : int in range [1, +inf), optional
        Broj vrijednosti koje se predviđa (zadana vrijednost je 1).

    theta : float in range [0, 1] or tuple of 3 floats in range [0, 1]
        Parametri eksponencijalnog izglađivanja (zadana vrijednost je 0.5).
        Ako je jedinstvena vrijednost, uzima se
        `theta = (theta, theta, theta)`.  Vrijednost `theta[0]` koeficijent
        je izglađivanja visine, vrijednost `theta[1]` koeficijent je
        izglađivanja trenda, a vrijednost `theta[2]` je koeficijent
        izglađivanja sezonalnih komponenti.

    Povratne vrijednosti
    --------------------
    y : array
        Predviđenih `k` vrijednosti tenzora `a`.  Prvih `a.ndim - 1`
        dimenzija jednakih je veličina kao tenzora `a`, a posljednja
        dimenzija je veličine `k`.  Ako je `k == 1`, onda je povratna
        vrijednost dimenzionalnosti `a.ndim - 1`.  Ako je `a`
        jednodimenzionalni tenzor i `k == 1`, onda je povratna vrijednost
        skalar.

    Iznimke
    -------
    TypeError
        Parametar `k` nije realni broj, parametar `theta` sadrži vrijednost
        koja nije realni broj.

    ValueError
        Parametar `k` nije u intervalu [1, +inf), parametar `theta` sadrži
        vrijednost koja nije u intervalu [0, 1].

    &#34;&#34;&#34;

    # Saniraj parametar self.
    if not isinstance(self, ExponentialSmooth):
        raise TypeError(&#39;self mora biti klase ExponentialSmooth.&#39;)

    # Saniraj parametar k.
    if not isinstance(k, _numbers.Integral):
        raise TypeError(&#39;k mora biti klase int.&#39;)
    try:
        k = _copy.deepcopy(int(k))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;k mora biti klase int.&#39;)
    if k &lt;= 0:
        raise ValueError(&#39;k mora biti strogo pozitivan.&#39;)

    # Saniraj parametar theta.
    if not isinstance(theta, tuple):
        theta = _copy.deepcopy((theta, theta, theta))
    if len(theta) != 3:
        raise ValueError(&#39;theta mora biti troclani tuple.&#39;)
    theta = list(theta)
    for i in iter(range(3)):
        if not (isinstance(theta[i], _numbers.Real)):
            raise TypeError(&#39;theta mora biti klase float.&#39;)
        try:
            theta[i] = _copy.deepcopy(float(theta[i]))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;theta mora biti klase float.&#39;)
        if _math.isnan(theta[i]) or _math.isinf(theta[i]):
            raise ValueError(&#39;theta ne smije biti NaN ili beskonacno.&#39;)
        if theta[i] &lt; 0.0 or theta[i] &gt; 1.0:
            raise ValueError(&#39;theta mora biti u intervalu [0, 1].&#39;)
    theta = tuple(theta)

    # Izračunaj 1 - theta po komponentama.
    one_min_theta = (1.0 - theta[0], 1.0 - theta[1], 1.0 - theta[2])

    # Eksponencijalnim izglađivanjem izračunaj tenzor y duljine
    # a.shape[-1] + k.
    y = None
    if self._a.ndim == 1:
        y = _np.zeros(self._a.size + k, dtype = self._s.dtype, order = &#39;F&#39;)
    else:
        y = _np.zeros(
            tuple(
                _np.concatenate(
                    ([self._a.shape[0] + k], self._a.shape[1:])
                ).tolist()
            ),
            dtype = self._s.dtype,
            order = &#39;F&#39;
    )
    b = _copy.deepcopy(self._b)
    s = _copy.deepcopy(self._s)
    l = (_copy.deepcopy(self._a[0]), _copy.deepcopy(self._a[0]))
    for i in iter(range(1, int(self._a.shape[0]))):
        val = _copy.deepcopy(self._a[i])
        l = (
            l[1],
            (
                theta[0] * (val - s[i % self._n]) +
                one_min_theta[0] * (l[1] + b)
            )
        )
        b = theta[1] * (l[1] - l[0]) + one_min_theta[1] * b
        s[i % self._n] = (
            theta[2] * (val - l[1]) + one_min_theta[2] * s[i % self._n]
        )
        y[i] = l[1] + b + s[i % self._n]
    for i in iter(range(int(self._a.shape[0]), int(y.shape[0]))):
        y[i] = (l[1] + (i - self._a.shape[0] + 1) * b) + s[i % self._n]

    # Spremi samo posljednjih k vrijednosti u tenzoru y.
    y = y[int(self._a.shape[0]):].copy(order = &#39;F&#39;)

    # Po potrebi pojednostavi dimenzionalnost tenzora y odnosno pretvori ga
    # u skalar.
    if isinstance(y, _np.ndarray):
        if k == 1:
            if y.ndim == 1:
                y = y.dtype.type(y)
            else:
                y.shape = y.shape[1:]
        else:
            y = _np.moveaxis(y, 0, -1).copy(order = &#39;F&#39;)

    # Vrati izračunati tenzor y.
    return y</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#zavisnosti">Zavisnosti</a></li>
<li><a href="#napomene">Napomene</a></li>
<li><a href="#literatura">Literatura</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tlp.bt_Katz_score" href="#tlp.bt_Katz_score">bt_Katz_score</a></code></li>
<li><code><a title="tlp.cp_score" href="#tlp.cp_score">cp_score</a></code></li>
<li><code><a title="tlp.cwt" href="#tlp.cwt">cwt</a></code></li>
<li><code><a title="tlp.rand_fft" href="#tlp.rand_fft">rand_fft</a></code></li>
<li><code><a title="tlp.t_Katz_score" href="#tlp.t_Katz_score">t_Katz_score</a></code></li>
<li><code><a title="tlp.tsvd" href="#tlp.tsvd">tsvd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tlp.ExponentialSmooth" href="#tlp.ExponentialSmooth">ExponentialSmooth</a></code></h4>
<ul class="">
<li><code><a title="tlp.ExponentialSmooth.fit" href="#tlp.ExponentialSmooth.fit">fit</a></code></li>
<li><code><a title="tlp.ExponentialSmooth.initial_seasonal_components_" href="#tlp.ExponentialSmooth.initial_seasonal_components_">initial_seasonal_components_</a></code></li>
<li><code><a title="tlp.ExponentialSmooth.initial_trend_" href="#tlp.ExponentialSmooth.initial_trend_">initial_trend_</a></code></li>
<li><code><a title="tlp.ExponentialSmooth.predict" href="#tlp.ExponentialSmooth.predict">predict</a></code></li>
<li><code><a title="tlp.ExponentialSmooth.season_length_" href="#tlp.ExponentialSmooth.season_length_">season_length_</a></code></li>
<li><code><a title="tlp.ExponentialSmooth.series_" href="#tlp.ExponentialSmooth.series_">series_</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>